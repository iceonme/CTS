"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/agents/cfo.ts":
/*!***************************!*\
  !*** ./lib/agents/cfo.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CFOAgent: function() { return /* binding */ CFOAgent; },\n/* harmony export */   getCFOAgent: function() { return /* binding */ getCFOAgent; }\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"(app-pages-browser)/./lib/agents/base.ts\");\n/* harmony import */ var _tech_analyst__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tech-analyst */ \"(app-pages-browser)/./lib/agents/tech-analyst.ts\");\n/* harmony import */ var _lib_cfo_reasoning__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/cfo/reasoning */ \"(app-pages-browser)/./lib/cfo/reasoning.ts\");\n/* harmony import */ var _lib_feed_publisher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/feed/publisher */ \"(app-pages-browser)/./lib/feed/publisher.ts\");\n/* harmony import */ var _lib_trading_portfolio__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/trading/portfolio */ \"(app-pages-browser)/./lib/trading/portfolio.ts\");\n/**\n * CFO Agent\n * 首席财务官 - 负责市场分析决策和整体策略\n */ \n\n\n\n\nclass CFOAgent extends _base__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    // ==================== 核心分析方法 ====================\n    /**\n   * 分析单个币种\n   */ async analyzeSymbol(symbol) {\n        const task = {\n            id: \"cfo-task-\".concat(Date.now()),\n            type: \"analyze_symbol\",\n            data: {\n                symbol\n            },\n            priority: \"high\",\n            createdAt: new Date()\n        };\n        const result = await this.techAnalyst.processTask(task);\n        if (!result.success || !result.data) {\n            throw new Error(result.error || \"技术分析失败\");\n        }\n        const cfoAnalysis = (0,_lib_cfo_reasoning__WEBPACK_IMPORTED_MODULE_2__.analyzeWithCFO)(result.data);\n        this.cacheAnalysis(cfoAnalysis);\n        return cfoAnalysis;\n    }\n    /**\n   * 分析多个币种\n   */ async analyzeMultiple(symbols) {\n        const analyses = [];\n        for (const symbol of symbols){\n            try {\n                const analysis = await this.analyzeSymbol(symbol);\n                analyses.push(analysis);\n            } catch (error) {\n                console.error(\"[CFO] 分析 \".concat(symbol, \" 失败:\"), error);\n                // 返回一个带有错误状态的 mock 分析，而不是让整个流程失败\n                analyses.push(this.createErrorAnalysis(symbol, error instanceof Error ? error.message : \"未知错误\"));\n            }\n            // 增加延迟避免 429 限速（CoinGecko 免费版：50 req/min = 1.2s/req）\n            await this.delay(1300);\n        }\n        return analyses;\n    }\n    /**\n   * 创建错误分析占位符\n   */ createErrorAnalysis(symbol, errorMessage) {\n        const now = new Date();\n        return {\n            id: \"cfo-error-\".concat(Date.now(), \"-\").concat(symbol),\n            symbol,\n            timestamp: now,\n            perspectives: {\n                bull: {\n                    mode: \"bull\",\n                    confidence: 0,\n                    reasoning: \"数据暂时不可用\",\n                    keyPoints: [\n                        \"无法获取市场数据，请稍后重试\"\n                    ],\n                    riskLevel: \"medium\"\n                },\n                bear: {\n                    mode: \"bear\",\n                    confidence: 0,\n                    reasoning: \"数据暂时不可用\",\n                    keyPoints: [\n                        errorMessage.includes(\"429\") ? \"API 限速，请稍后再试\" : \"网络连接问题\"\n                    ],\n                    riskLevel: \"medium\"\n                }\n            },\n            consensus: {\n                sentiment: \"neutral\",\n                confidence: 0,\n                summary: errorMessage.includes(\"429\") ? \"API 请求过于频繁，请稍后重试\" : \"数据加载失败，请刷新页面重试\",\n                action: \"watch\"\n            },\n            technicalData: {\n                symbol,\n                indicators: {\n                    rsi: 50,\n                    ma7: 0,\n                    ma14: 0,\n                    volatility: 0,\n                    trend: \"sideways\"\n                },\n                signals: [],\n                timestamp: now\n            }\n        };\n    }\n    /**\n   * 获取市场概览\n   */ async getMarketOverview() {\n        // 分析主要币种\n        const symbols = [\n            \"BTC\",\n            \"ETH\",\n            \"DOGE\",\n            \"SOL\"\n        ];\n        const analyses = await this.analyzeMultiple(symbols);\n        // 计算整体情绪\n        let bullishCount = 0;\n        let bearishCount = 0;\n        let neutralCount = 0;\n        let errorCount = 0;\n        const opportunities = [];\n        const risks = [];\n        for (const analysis of analyses){\n            // 跳过错误分析\n            if (analysis.consensus.confidence === 0 && analysis.perspectives.bull.confidence === 0) {\n                errorCount++;\n                continue;\n            }\n            switch(analysis.consensus.sentiment){\n                case \"bullish\":\n                    bullishCount++;\n                    if (analysis.consensus.confidence > 0.6) {\n                        opportunities.push(analysis.symbol);\n                    }\n                    break;\n                case \"bearish\":\n                    bearishCount++;\n                    if (analysis.consensus.confidence > 0.6) {\n                        risks.push(analysis.symbol);\n                    }\n                    break;\n                case \"neutral\":\n                    neutralCount++;\n                    break;\n            }\n        }\n        const validAnalyses = analyses.length - errorCount;\n        let overallSentiment;\n        let summary;\n        if (validAnalyses === 0) {\n            overallSentiment = \"neutral\";\n            summary = \"数据加载失败，请稍后刷新页面重试。\";\n        } else if (bullishCount > bearishCount && bullishCount > neutralCount) {\n            overallSentiment = \"bullish\";\n            summary = \"市场呈现看涨势头，\".concat(bullishCount, \"/\").concat(validAnalyses, \" 个资产呈积极态势。\");\n        } else if (bearishCount > bullishCount && bearishCount > neutralCount) {\n            overallSentiment = \"bearish\";\n            summary = \"市场承压，\".concat(bearishCount, \"/\").concat(validAnalyses, \" 个资产呈消极态势。\");\n        } else {\n            overallSentiment = \"neutral\";\n            summary = \"市场信号混杂，\".concat(neutralCount, \"/\").concat(validAnalyses, \" 个资产呈中性态势。\");\n        }\n        return {\n            analyses,\n            overallSentiment,\n            topOpportunities: opportunities.slice(0, 3),\n            topRisks: risks.slice(0, 3),\n            summary\n        };\n    }\n    // ==================== 生成洞察 ====================\n    /**\n   * 生成 CFO 洞察\n   */ generateInsights(analyses) {\n        const insights = [];\n        for (const analysis of analyses){\n            const { symbol, consensus, perspectives } = analysis;\n            // 强信号洞察\n            if (consensus.confidence > 0.7) {\n                insights.push({\n                    type: consensus.sentiment === \"bullish\" ? \"opportunity\" : \"warning\",\n                    title: \"\".concat(symbol, \" \").concat(consensus.sentiment === \"bullish\" ? \"Opportunity\" : \"Risk Alert\"),\n                    content: consensus.summary,\n                    confidence: consensus.confidence,\n                    relatedSymbols: [\n                        symbol\n                    ],\n                    timestamp: new Date()\n                });\n            }\n            // 观点分歧洞察\n            const bullConf = perspectives.bull.confidence;\n            const bearConf = perspectives.bear.confidence;\n            if (Math.abs(bullConf - bearConf) < 0.2 && bullConf > 0.4 && bearConf > 0.4) {\n                insights.push({\n                    type: \"market_outlook\",\n                    title: \"\".concat(symbol, \" at Critical Juncture\"),\n                    content: \"Bull case (\".concat((bullConf * 100).toFixed(0), \"% confidence) vs Bear case (\").concat((bearConf * 100).toFixed(0), \"% confidence). Market direction unclear.\"),\n                    confidence: 0.5,\n                    relatedSymbols: [\n                        symbol\n                    ],\n                    timestamp: new Date()\n                });\n            }\n        }\n        return insights.sort((a, b)=>b.confidence - a.confidence);\n    }\n    // ==================== 基于 Feed 的智能判断 ====================\n    /**\n   * 基于 Feed 情报做交易决策\n   * 综合分析所有 Agent 发布的情报，给出交易建议\n   */ async analyzeFromFeed(symbols) {\n        const targetSymbols = symbols || [\n            \"BTC\",\n            \"DOGE\"\n        ];\n        const recommendations = [];\n        // 获取最近的情报（30分钟内）\n        const recentFeeds = (0,_lib_feed_publisher__WEBPACK_IMPORTED_MODULE_3__.getFeedItems)({\n            limit: 50\n        });\n        const thirtyMinutesAgo = Date.now() - 30 * 60 * 1000;\n        const relevantFeeds = recentFeeds.filter((f)=>f.timestamp.getTime() > thirtyMinutesAgo);\n        for (const symbol of targetSymbols){\n            // 筛选该币种相关的情报\n            const symbolFeeds = relevantFeeds.filter((f)=>f.symbol === symbol || f.title.includes(symbol));\n            // 分类统计\n            const techSignals = symbolFeeds.filter((f)=>f.type === \"technical_signal\");\n            const paAnalyses = symbolFeeds.filter((f)=>f.type === \"pa_analysis\");\n            const sentimentFeeds = symbolFeeds.filter((f)=>f.type === \"sentiment_shift\");\n            // 计算综合得分\n            let bullishScore = 0;\n            let bearishScore = 0;\n            let totalWeight = 0;\n            // 技术分析权重 40%\n            techSignals.forEach((feed)=>{\n                const data = feed.data;\n                if ((data === null || data === void 0 ? void 0 : data.signalType) === \"buy\" || (data === null || data === void 0 ? void 0 : data.signalType) === \"strong_buy\") {\n                    bullishScore += (data.signalConfidence || 0.5) * 0.4;\n                    totalWeight += 0.4;\n                } else if ((data === null || data === void 0 ? void 0 : data.signalType) === \"sell\" || (data === null || data === void 0 ? void 0 : data.signalType) === \"strong_sell\") {\n                    bearishScore += (data.signalConfidence || 0.5) * 0.4;\n                    totalWeight += 0.4;\n                }\n            });\n            // PA 研判权重 35%\n            paAnalyses.forEach((feed)=>{\n                const data = feed.data;\n                const bullConf = (data === null || data === void 0 ? void 0 : data.bullConfidence) || 0;\n                const bearConf = (data === null || data === void 0 ? void 0 : data.bearConfidence) || 0;\n                const consensus = data === null || data === void 0 ? void 0 : data.consensusSentiment;\n                if (consensus === \"bullish\") {\n                    bullishScore += bullConf * 0.35;\n                    totalWeight += 0.35;\n                } else if (consensus === \"bearish\") {\n                    bearishScore += bearConf * 0.35;\n                    totalWeight += 0.35;\n                }\n            });\n            // 预测市场情绪权重 25%\n            sentimentFeeds.forEach((feed)=>{\n                const data = feed.data;\n                const sentiment = data === null || data === void 0 ? void 0 : data.sentiment;\n                if (sentiment > 0.6) {\n                    bullishScore += sentiment * 0.25;\n                    totalWeight += 0.25;\n                } else if (sentiment < 0.4) {\n                    bearishScore += (1 - sentiment) * 0.25;\n                    totalWeight += 0.25;\n                }\n            });\n            // 计算置信度和决策\n            const confidence = totalWeight > 0 ? Math.abs(bullishScore - bearishScore) / totalWeight : 0;\n            let action;\n            let reasoning = \"\";\n            let positionSize = \"small\";\n            let percentage = 10;\n            if (confidence < 0.3) {\n                action = \"watch\";\n                reasoning = \"信号不明确，建议观望。技术信号\".concat(techSignals.length, \"个，PA研判\").concat(paAnalyses.length, \"个。\");\n            } else if (bullishScore > bearishScore) {\n                action = confidence > 0.7 ? \"buy\" : \"hold\";\n                positionSize = confidence > 0.8 ? \"large\" : confidence > 0.6 ? \"medium\" : \"small\";\n                percentage = Math.round(confidence * 30); // 最多30%仓位\n                reasoning = \"综合\".concat(techSignals.length, \"个技术信号和\").concat(paAnalyses.length, \"个PA研判，看涨因素占优。\");\n            } else {\n                action = confidence > 0.7 ? \"sell\" : \"hold\";\n                positionSize = confidence > 0.8 ? \"large\" : confidence > 0.6 ? \"medium\" : \"small\";\n                percentage = Math.round(confidence * 25);\n                reasoning = \"综合\".concat(techSignals.length, \"个技术信号和\").concat(paAnalyses.length, \"个PA研判，看跌因素占优。\");\n            }\n            // 获取当前价格用于计算止损止盈\n            const currentPrice = await this.getCurrentPrice(symbol);\n            const stopLoss = action === \"buy\" ? currentPrice * 0.95 : action === \"sell\" ? currentPrice * 1.05 : undefined;\n            const takeProfit = action === \"buy\" ? currentPrice * 1.1 : action === \"sell\" ? currentPrice * 0.9 : undefined;\n            recommendations.push({\n                symbol,\n                action,\n                confidence: Math.round(confidence * 100) / 100,\n                reasoning,\n                position: {\n                    size: positionSize,\n                    percentage\n                },\n                stopLoss,\n                takeProfit,\n                timeframe: \"短期（1-3天）\"\n            });\n        }\n        return recommendations;\n    }\n    /**\n   * 获取当前价格（简化版，实际应从缓存或API获取）\n   */ async getCurrentPrice(symbol) {\n        const mockPrices = {\n            BTC: 50000,\n            DOGE: 0.15,\n            ETH: 3000,\n            SOL: 100\n        };\n        return mockPrices[symbol] || 100;\n    }\n    /**\n   * 执行交易\n   * 直接调用 Portfolio，不做复杂风控（风控由 PA 决策时控制）\n   */ async executeTrade(params) {\n        const portfolio = (0,_lib_trading_portfolio__WEBPACK_IMPORTED_MODULE_4__.getPortfolioManager)();\n        try {\n            // 买入需要 amount，卖出需要 quantity\n            if (params.side === \"buy\" && !params.amount) {\n                return {\n                    success: false,\n                    error: \"买入必须提供 amount (USD)\"\n                };\n            }\n            if (params.side === \"sell\" && !params.quantity) {\n                return {\n                    success: false,\n                    error: \"卖出必须提供 quantity\"\n                };\n            }\n            // 获取当前价格计算数量\n            let quantity = params.quantity || 0;\n            const price = this.mockPrices[params.symbol.toUpperCase()] || 100;\n            if (params.side === \"buy\" && params.amount) {\n                quantity = params.amount / price;\n            }\n            // 执行交易\n            const result = portfolio.executeTrade({\n                symbol: params.symbol.toUpperCase(),\n                side: params.side,\n                type: \"market\",\n                quantity,\n                price,\n                notes: params.reason || \"\".concat(params.side.toUpperCase(), \" \").concat(params.symbol)\n            });\n            if (!result.success) {\n                return {\n                    success: false,\n                    error: result.error\n                };\n            }\n            // 获取更新后的 Portfolio\n            const current = portfolio.getPortfolio();\n            return {\n                success: true,\n                trade: result.trade ? {\n                    id: result.trade.id,\n                    symbol: result.trade.symbol,\n                    side: result.trade.side,\n                    quantity: result.trade.quantity,\n                    price: result.trade.price,\n                    total: result.trade.total,\n                    fee: result.trade.fee\n                } : undefined,\n                portfolio: {\n                    totalEquity: current.totalEquity,\n                    balance: current.balance,\n                    positions: current.positions.map((p)=>({\n                            symbol: p.symbol,\n                            quantity: p.quantity,\n                            avgPrice: p.avgPrice\n                        }))\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : \"交易执行失败\"\n            };\n        }\n    }\n    /**\n   * 一键分析并执行交易\n   */ async analyzeAndTrade(symbols) {\n        let autoExecute = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        // 1. 分析\n        const analyses = await this.analyzeFromFeed(symbols);\n        // 2. 如果启用自动执行，执行交易\n        const executions = [];\n        if (autoExecute) {\n            for (const rec of analyses){\n                // 只执行 buy/sell，跳过 hold/watch\n                if (rec.action === \"buy\" || rec.action === \"sell\") {\n                    // 根据建议仓位计算金额\n                    const portfolio = (0,_lib_trading_portfolio__WEBPACK_IMPORTED_MODULE_4__.getPortfolioManager)();\n                    const equity = portfolio.getPortfolio().totalEquity;\n                    const amount = equity * rec.position.percentage / 100;\n                    const result = await this.executeTrade({\n                        symbol: rec.symbol,\n                        side: rec.action,\n                        amount: rec.action === \"buy\" ? amount : undefined,\n                        quantity: rec.action === \"sell\" ? rec.position.percentage : undefined,\n                        reason: rec.reasoning\n                    });\n                    executions.push(result);\n                }\n            }\n        }\n        return {\n            analyses,\n            executions\n        };\n    }\n    /**\n   * 格式化 Feed 分析为交易建议\n   */ formatTradeRecommendation(rec) {\n        const actionEmoji = rec.action === \"buy\" ? \"\\uD83D\\uDFE2 买入\" : rec.action === \"sell\" ? \"\\uD83D\\uDD34 卖出\" : rec.action === \"hold\" ? \"\\uD83D\\uDFE1 持有\" : \"⚪ 观望\";\n        const sizeText = rec.position.size === \"large\" ? \"重仓\" : rec.position.size === \"medium\" ? \"中仓\" : \"轻仓\";\n        let response = \"**\".concat(rec.symbol, \" 交易建议**\\n\\n\");\n        response += \"\".concat(actionEmoji, \" | 置信度: \").concat((rec.confidence * 100).toFixed(0), \"%\\n\");\n        response += \"建议仓位: \".concat(sizeText, \" (\").concat(rec.position.percentage, \"%)\\n\\n\");\n        response += \"\\uD83D\\uDCA1 **判断依据**: \".concat(rec.reasoning, \"\\n\\n\");\n        if (rec.stopLoss && rec.takeProfit) {\n            response += \"\\uD83D\\uDED1 止损: $\".concat(rec.stopLoss.toFixed(rec.symbol === \"DOGE\" ? 4 : 0), \"\\n\");\n            response += \"\\uD83C\\uDFAF 止盈: $\".concat(rec.takeProfit.toFixed(rec.symbol === \"DOGE\" ? 4 : 0), \"\\n\");\n        }\n        response += \"⏰ 时间框架: \".concat(rec.timeframe);\n        return response;\n    }\n    // ==================== 格式化输出 ====================\n    /**\n   * 格式化分析结果为对话回复\n   */ formatAnalysisForChat(analysis) {\n        const { symbol, consensus, perspectives, technicalData } = analysis;\n        // 如果是错误分析，返回简洁错误信息\n        if (analysis.consensus.confidence === 0 && analysis.perspectives.bull.confidence === 0) {\n            return \"\\uD83D\\uDCCA **\".concat(symbol, \" 分析报告**\\n\\n\").concat(analysis.consensus.summary);\n        }\n        let response = \"\\uD83D\\uDCCA **\".concat(symbol, \" 分析报告**\\n\\n\");\n        // 技术指标概览\n        response += \"**技术指标：**\\n\";\n        response += \"- RSI: \".concat(technicalData.indicators.rsi, \"\\n\");\n        response += \"- MA7: $\".concat(technicalData.indicators.ma7.toLocaleString(), \"\\n\");\n        response += \"- MA14: $\".concat(technicalData.indicators.ma14.toLocaleString(), \"\\n\");\n        response += \"- 趋势: \".concat(technicalData.indicators.trend === \"up\" ? \"上涨\" : technicalData.indicators.trend === \"down\" ? \"下跌\" : \"横盘\", \"\\n\\n\");\n        // Bull Case\n        response += \"\\uD83D\\uDC02 **看涨观点** (\".concat((perspectives.bull.confidence * 100).toFixed(0), \"% 置信度)\\n\");\n        perspectives.bull.keyPoints.slice(0, 2).forEach((point)=>{\n            response += \"- \".concat(point, \"\\n\");\n        });\n        response += \"\\n\";\n        // Bear Case\n        response += \"\\uD83D\\uDC3B **看跌观点** (\".concat((perspectives.bear.confidence * 100).toFixed(0), \"% 置信度)\\n\");\n        perspectives.bear.keyPoints.slice(0, 2).forEach((point)=>{\n            response += \"- \".concat(point, \"\\n\");\n        });\n        response += \"\\n\";\n        // 结论\n        const emoji = consensus.action === \"buy\" ? \"\\uD83D\\uDFE2\" : consensus.action === \"sell\" ? \"\\uD83D\\uDD34\" : \"\\uD83D\\uDFE1\";\n        const actionText = consensus.action === \"buy\" ? \"买入\" : consensus.action === \"sell\" ? \"卖出\" : consensus.action === \"watch\" ? \"观望\" : \"持有\";\n        response += \"\".concat(emoji, \" **CFO 建议: \").concat(actionText, \"**\\n\");\n        response += \"置信度: \".concat((consensus.confidence * 100).toFixed(0), \"% | 情绪: \").concat(consensus.sentiment === \"bullish\" ? \"看涨\" : consensus.sentiment === \"bearish\" ? \"看跌\" : \"中性\", \"\\n\");\n        response += \"> \".concat(consensus.summary);\n        return response;\n    }\n    /**\n   * 格式化市场概览\n   */ formatMarketOverview(overview) {\n        let response = \"\\uD83C\\uDF0D **市场概览**\\n\\n\";\n        const sentimentText = overview.overallSentiment === \"bullish\" ? \"看涨\" : overview.overallSentiment === \"bearish\" ? \"看跌\" : \"中性\";\n        response += \"**整体情绪：** \".concat(sentimentText, \"\\n\");\n        response += \"\".concat(overview.summary, \"\\n\\n\");\n        if (overview.topOpportunities.length > 0) {\n            response += \"\\uD83D\\uDFE2 **机会：** \".concat(overview.topOpportunities.join(\", \"), \"\\n\");\n        }\n        if (overview.topRisks.length > 0) {\n            response += \"\\uD83D\\uDD34 **风险：** \".concat(overview.topRisks.join(\", \"), \"\\n\");\n        }\n        response += \"\\n**资产摘要：**\\n\";\n        for (const analysis of overview.analyses){\n            const emoji = analysis.consensus.sentiment === \"bullish\" ? \"\\uD83D\\uDFE2\" : analysis.consensus.sentiment === \"bearish\" ? \"\\uD83D\\uDD34\" : \"⚪\";\n            const actionText = analysis.consensus.action === \"buy\" ? \"买入\" : analysis.consensus.action === \"sell\" ? \"卖出\" : analysis.consensus.action === \"watch\" ? \"观望\" : \"持有\";\n            response += \"\".concat(emoji, \" \").concat(analysis.symbol, \": \").concat(actionText, \" (\").concat((analysis.consensus.confidence * 100).toFixed(0), \"%)\\n\");\n        }\n        return response;\n    }\n    // ==================== 缓存管理 ====================\n    cacheAnalysis(analysis) {\n        this.recentAnalyses.set(analysis.symbol, analysis);\n        // 保持缓存大小限制\n        if (this.recentAnalyses.size > this.maxCacheSize) {\n            const firstKey = this.recentAnalyses.keys().next().value;\n            if (firstKey) {\n                this.recentAnalyses.delete(firstKey);\n            }\n        }\n    }\n    getCachedAnalysis(symbol) {\n        return this.recentAnalyses.get(symbol);\n    }\n    getAllCachedAnalyses() {\n        return Array.from(this.recentAnalyses.values());\n    }\n    // ==================== 实现抽象方法 ====================\n    async executeTask(task) {\n        const data = task.data;\n        switch(data.type){\n            case \"single_analysis\":\n                {\n                    if (!data.symbol) throw new Error(\"单次分析需要指定币种\");\n                    const result = await this.analyzeSymbol(data.symbol);\n                    return result;\n                }\n            case \"market_overview\":\n                {\n                    const result = await this.getMarketOverview();\n                    return result;\n                }\n            case \"portfolio_review\":\n                {\n                    var _data_portfolio;\n                    const symbols = ((_data_portfolio = data.portfolio) === null || _data_portfolio === void 0 ? void 0 : _data_portfolio.map((p)=>p.symbol)) || [\n                        \"BTC\",\n                        \"ETH\"\n                    ];\n                    const result = await this.analyzeMultiple(symbols);\n                    return result;\n                }\n            default:\n                throw new Error(\"未知的 CFO 任务类型: \".concat(data.type));\n        }\n    }\n    async generateResponse(message, context) {\n        const lowerMsg = message.toLowerCase();\n        // 市场概览请求\n        if (lowerMsg.includes(\"overview\") || lowerMsg.includes(\"market\") || lowerMsg.includes(\"概览\") || lowerMsg.includes(\"市场\")) {\n            try {\n                const overview = await this.getMarketOverview();\n                return this.formatMarketOverview(overview);\n            } catch (error) {\n                return \"获取市场概览时遇到问题，请稍后再试。\";\n            }\n        }\n        // 特定币种分析\n        const symbolMatch = message.match(/\\b(BTC|DOGE|ETH|SOL|XRP|ADA|AVAX|DOT)\\b/i);\n        if (symbolMatch) {\n            const symbol = symbolMatch[0].toUpperCase();\n            try {\n                // 先检查缓存\n                const cached = this.getCachedAnalysis(symbol);\n                if (cached && Date.now() - cached.timestamp.getTime() < 5 * 60 * 1000) {\n                    return this.formatAnalysisForChat(cached) + \"\\n\\n*(缓存数据)*\";\n                }\n                const analysis = await this.analyzeSymbol(symbol);\n                return this.formatAnalysisForChat(analysis);\n            } catch (error) {\n                const errorMsg = error instanceof Error ? error.message : \"\";\n                if (errorMsg.includes(\"429\")) {\n                    return \"⏳ API 请求过于频繁，请等待 1-2 分钟后再试。\";\n                }\n                return \"暂时无法分析 \".concat(symbol, \"，市场数据可能暂时不可用。\");\n            }\n        }\n        // 默认回复\n        return \"我是你的 CFO 智能助手，可以帮你：\\n\\n\" + \"\\uD83D\\uDCCA **市场分析** - 询问 BTC、DOGE、ETH 等币种\\n\" + '\\uD83C\\uDF0D **市场概览** - 输入\"市场概览\"查看整体市场状况\\n' + \"\\uD83D\\uDCA1 **投资建议** - 提供买入/卖出/持有建议\\n\\n\" + \"你想分析什么？\";\n    }\n    constructor(){\n        super({\n            name: \"CFO\",\n            role: \"cfo\",\n            systemPrompt: \"你是 CryptoPulse AI 的首席财务官 (CFO)。\\n\\n你的职责：\\n1. 监督所有市场分析并做出战略决策\\n2. 使用双模式推理评估看涨和看跌观点\\n3. 提供明确的买入/卖出/持有建议及置信度\\n4. 评估投资组合风险和市场机会\\n5. 以专业、简洁的方式沟通\\n\\n始终在给出最终判断前呈现双方观点（Bull vs Bear）。\\n以数据驱动和量化的方式进行分析和输出。\"\n        });\n        this.recentAnalyses = new Map();\n        this.maxCacheSize = 20;\n        // ==================== 交易执行（简单直接）====================\n        // Mock 价格（实际生产环境应从 CoinGecko 获取）\n        this.mockPrices = {\n            BTC: 68400,\n            DOGE: 0.10,\n            ETH: 3500,\n            SOL: 150,\n            XRP: 0.6,\n            ADA: 0.4\n        };\n        this.techAnalyst = (0,_tech_analyst__WEBPACK_IMPORTED_MODULE_1__.getTechnicalAnalyst)();\n    }\n}\n// 单例模式导出\nlet cfoInstance = null;\nfunction getCFOAgent() {\n    if (!cfoInstance) {\n        cfoInstance = new CFOAgent();\n    }\n    return cfoInstance;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (CFOAgent);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QjlDLGFBQXFDO1lBQzNDQyxLQUFLO1lBQ0xDLE1BQU07WUFDTkMsS0FBSztZQUNMQyxLQUFLO1lBQ0xvRSxLQUFLO1lBQ0xDLEtBQUs7UUFDUDtRQWpYRSxJQUFJLENBQUM3SyxXQUFXLEdBQUdoQixrRUFBbUJBO0lBQ3hDO0FBMnRCRjtBQUVBLFNBQVM7QUFDVCxJQUFJOEwsY0FBK0I7QUFFNUIsU0FBU0M7SUFDZCxJQUFJLENBQUNELGFBQWE7UUFDaEJBLGNBQWMsSUFBSTFMO0lBQ3BCO0lBQ0EsT0FBTzBMO0FBQ1Q7QUFFQSwrREFBZTFMLFFBQVFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2FnZW50cy9jZm8udHM/NDAwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENGTyBBZ2VudFxuICog6aaW5bit6LSi5Yqh5a6YIC0g6LSf6LSj5biC5Zy65YiG5p6Q5Yaz562W5ZKM5pW05L2T562W55WlXG4gKi9cblxuaW1wb3J0IEJhc2VBZ2VudCBmcm9tIFwiLi9iYXNlXCI7XG5pbXBvcnQgeyBnZXRUZWNobmljYWxBbmFseXN0LCB0eXBlIFRlY2huaWNhbEFuYWx5c3QgfSBmcm9tIFwiLi90ZWNoLWFuYWx5c3RcIjtcbmltcG9ydCB7IGFuYWx5emVXaXRoQ0ZPLCBhbmFseXplTXVsdGlwbGVXaXRoQ0ZPIH0gZnJvbSBcIkAvbGliL2Nmby9yZWFzb25pbmdcIjtcbmltcG9ydCB7IGdldEZlZWRJdGVtcyB9IGZyb20gXCJAL2xpYi9mZWVkL3B1Ymxpc2hlclwiO1xuaW1wb3J0IHsgZ2V0UG9ydGZvbGlvTWFuYWdlciB9IGZyb20gXCJAL2xpYi90cmFkaW5nL3BvcnRmb2xpb1wiO1xuaW1wb3J0IHR5cGUgeyBBZ2VudFRhc2ssIE1hcmtldFNlbnRpbWVudCwgQ0ZPUGVyc3BlY3RpdmUsIENGT0FuYWx5c2lzLCBUZWNobmljYWxBbmFseXNpcywgSW50ZWxsaWdlbmNlSXRlbSB9IGZyb20gXCJAL2xpYi90eXBlc1wiO1xuXG5pbnRlcmZhY2UgQ0ZPVGFzayB7XG4gIHR5cGU6IFwic2luZ2xlX2FuYWx5c2lzXCIgfCBcIm1hcmtldF9vdmVydmlld1wiIHwgXCJwb3J0Zm9saW9fcmV2aWV3XCI7XG4gIHN5bWJvbHM/OiBzdHJpbmdbXTtcbiAgc3ltYm9sPzogc3RyaW5nO1xuICBwb3J0Zm9saW8/OiB7IHN5bWJvbDogc3RyaW5nOyBhbGxvY2F0aW9uOiBudW1iZXIgfVtdO1xufVxuXG5pbnRlcmZhY2UgQ0ZPSW5zaWdodCB7XG4gIHR5cGU6IFwibWFya2V0X291dGxvb2tcIiB8IFwicmlza19hc3Nlc3NtZW50XCIgfCBcIm9wcG9ydHVuaXR5XCIgfCBcIndhcm5pbmdcIjtcbiAgdGl0bGU6IHN0cmluZztcbiAgY29udGVudDogc3RyaW5nO1xuICBjb25maWRlbmNlOiBudW1iZXI7XG4gIHJlbGF0ZWRTeW1ib2xzOiBzdHJpbmdbXTtcbiAgdGltZXN0YW1wOiBEYXRlO1xufVxuXG5leHBvcnQgY2xhc3MgQ0ZPQWdlbnQgZXh0ZW5kcyBCYXNlQWdlbnQge1xuICBwcml2YXRlIHRlY2hBbmFseXN0OiBUZWNobmljYWxBbmFseXN0O1xuICBwcml2YXRlIHJlY2VudEFuYWx5c2VzOiBNYXA8c3RyaW5nLCBDRk9BbmFseXNpcz4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgbWF4Q2FjaGVTaXplID0gMjA7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJDRk9cIixcbiAgICAgIHJvbGU6IFwiY2ZvXCIsXG4gICAgICBzeXN0ZW1Qcm9tcHQ6IGDkvaDmmK8gQ3J5cHRvUHVsc2UgQUkg55qE6aaW5bit6LSi5Yqh5a6YIChDRk8p44CCXG5cbuS9oOeahOiBjOi0o++8mlxuMS4g55uR552j5omA5pyJ5biC5Zy65YiG5p6Q5bm25YGa5Ye65oiY55Wl5Yaz562WXG4yLiDkvb/nlKjlj4zmqKHlvI/mjqjnkIbor4TkvLDnnIvmtqjlkoznnIvot4zop4LngrlcbjMuIOaPkOS+m+aYjuehrueahOS5sOWFpS/ljZblh7ov5oyB5pyJ5bu66K6u5Y+K572u5L+h5bqmXG40LiDor4TkvLDmipXotYTnu4TlkIjpo47pmanlkozluILlnLrmnLrkvJpcbjUuIOS7peS4k+S4muOAgeeugOa0geeahOaWueW8j+ayn+mAmlxuXG7lp4vnu4jlnKjnu5nlh7rmnIDnu4jliKTmlq3liY3lkYjnjrDlj4zmlrnop4LngrnvvIhCdWxsIHZzIEJlYXLvvInjgIJcbuS7peaVsOaNrumpseWKqOWSjOmHj+WMlueahOaWueW8j+i/m+ihjOWIhuaekOWSjOi+k+WHuuOAgmAsXG4gICAgfSk7XG5cbiAgICB0aGlzLnRlY2hBbmFseXN0ID0gZ2V0VGVjaG5pY2FsQW5hbHlzdCgpO1xuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0g5qC45b+D5YiG5p6Q5pa55rOVID09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIOWIhuaekOWNleS4quW4geenjVxuICAgKi9cbiAgYXN5bmMgYW5hbHl6ZVN5bWJvbChzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8Q0ZPQW5hbHlzaXM+IHtcbiAgICBjb25zdCB0YXNrID0ge1xuICAgICAgaWQ6IGBjZm8tdGFzay0ke0RhdGUubm93KCl9YCxcbiAgICAgIHR5cGU6IFwiYW5hbHl6ZV9zeW1ib2xcIixcbiAgICAgIGRhdGE6IHsgc3ltYm9sIH0sXG4gICAgICBwcmlvcml0eTogXCJoaWdoXCIgYXMgY29uc3QsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudGVjaEFuYWx5c3QucHJvY2Vzc1Rhc2sodGFzayk7XG5cbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzIHx8ICFyZXN1bHQuZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvciB8fCBcIuaKgOacr+WIhuaekOWksei0pVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBjZm9BbmFseXNpcyA9IGFuYWx5emVXaXRoQ0ZPKHJlc3VsdC5kYXRhIGFzIFRlY2huaWNhbEFuYWx5c2lzKTtcbiAgICB0aGlzLmNhY2hlQW5hbHlzaXMoY2ZvQW5hbHlzaXMpO1xuXG4gICAgcmV0dXJuIGNmb0FuYWx5c2lzO1xuICB9XG5cbiAgLyoqXG4gICAqIOWIhuaekOWkmuS4quW4geenjVxuICAgKi9cbiAgYXN5bmMgYW5hbHl6ZU11bHRpcGxlKHN5bWJvbHM6IHN0cmluZ1tdKTogUHJvbWlzZTxDRk9BbmFseXNpc1tdPiB7XG4gICAgY29uc3QgYW5hbHlzZXM6IENGT0FuYWx5c2lzW10gPSBbXTtcblxuICAgIGZvciAoY29uc3Qgc3ltYm9sIG9mIHN5bWJvbHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFuYWx5c2lzID0gYXdhaXQgdGhpcy5hbmFseXplU3ltYm9sKHN5bWJvbCk7XG4gICAgICAgIGFuYWx5c2VzLnB1c2goYW5hbHlzaXMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW0NGT10g5YiG5p6QICR7c3ltYm9sfSDlpLHotKU6YCwgZXJyb3IpO1xuICAgICAgICAvLyDov5Tlm57kuIDkuKrluKbmnInplJnor6/nirbmgIHnmoQgbW9jayDliIbmnpDvvIzogIzkuI3mmK/orqnmlbTkuKrmtYHnqIvlpLHotKVcbiAgICAgICAgYW5hbHlzZXMucHVzaCh0aGlzLmNyZWF0ZUVycm9yQW5hbHlzaXMoc3ltYm9sLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICfmnKrnn6XplJnor68nKSk7XG4gICAgICB9XG4gICAgICAvLyDlop7liqDlu7bov5/pgb/lhY0gNDI5IOmZkOmAn++8iENvaW5HZWNrbyDlhY3otLnniYjvvJo1MCByZXEvbWluID0gMS4ycy9yZXHvvIlcbiAgICAgIGF3YWl0IHRoaXMuZGVsYXkoMTMwMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuYWx5c2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIOWIm+W7uumUmeivr+WIhuaekOWNoOS9jeesplxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVFcnJvckFuYWx5c2lzKHN5bWJvbDogc3RyaW5nLCBlcnJvck1lc3NhZ2U6IHN0cmluZyk6IENGT0FuYWx5c2lzIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogYGNmby1lcnJvci0ke0RhdGUubm93KCl9LSR7c3ltYm9sfWAsXG4gICAgICBzeW1ib2wsXG4gICAgICB0aW1lc3RhbXA6IG5vdyxcbiAgICAgIHBlcnNwZWN0aXZlczoge1xuICAgICAgICBidWxsOiB7XG4gICAgICAgICAgbW9kZTogXCJidWxsXCIsXG4gICAgICAgICAgY29uZmlkZW5jZTogMCxcbiAgICAgICAgICByZWFzb25pbmc6IFwi5pWw5o2u5pqC5pe25LiN5Y+v55SoXCIsXG4gICAgICAgICAga2V5UG9pbnRzOiBbXCLml6Dms5Xojrflj5bluILlnLrmlbDmja7vvIzor7fnqI3lkI7ph43or5VcIl0sXG4gICAgICAgICAgcmlza0xldmVsOiBcIm1lZGl1bVwiLFxuICAgICAgICB9LFxuICAgICAgICBiZWFyOiB7XG4gICAgICAgICAgbW9kZTogXCJiZWFyXCIsXG4gICAgICAgICAgY29uZmlkZW5jZTogMCxcbiAgICAgICAgICByZWFzb25pbmc6IFwi5pWw5o2u5pqC5pe25LiN5Y+v55SoXCIsXG4gICAgICAgICAga2V5UG9pbnRzOiBbZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCc0MjknKSA/ICdBUEkg6ZmQ6YCf77yM6K+356iN5ZCO5YaN6K+VJyA6ICfnvZHnu5zov57mjqXpl67popgnXSxcbiAgICAgICAgICByaXNrTGV2ZWw6IFwibWVkaXVtXCIsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgY29uc2Vuc3VzOiB7XG4gICAgICAgIHNlbnRpbWVudDogXCJuZXV0cmFsXCIsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAsXG4gICAgICAgIHN1bW1hcnk6IGVycm9yTWVzc2FnZS5pbmNsdWRlcygnNDI5JykgPyBcIkFQSSDor7fmsYLov4fkuo7popHnuYHvvIzor7fnqI3lkI7ph43or5VcIiA6IFwi5pWw5o2u5Yqg6L295aSx6LSl77yM6K+35Yi35paw6aG16Z2i6YeN6K+VXCIsXG4gICAgICAgIGFjdGlvbjogXCJ3YXRjaFwiLFxuICAgICAgfSxcbiAgICAgIHRlY2huaWNhbERhdGE6IHtcbiAgICAgICAgc3ltYm9sLFxuICAgICAgICBpbmRpY2F0b3JzOiB7XG4gICAgICAgICAgcnNpOiA1MCxcbiAgICAgICAgICBtYTc6IDAsXG4gICAgICAgICAgbWExNDogMCxcbiAgICAgICAgICB2b2xhdGlsaXR5OiAwLFxuICAgICAgICAgIHRyZW5kOiBcInNpZGV3YXlzXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25hbHM6IFtdLFxuICAgICAgICB0aW1lc3RhbXA6IG5vdyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiDojrflj5bluILlnLrmpoLop4hcbiAgICovXG4gIGFzeW5jIGdldE1hcmtldE92ZXJ2aWV3KCk6IFByb21pc2U8e1xuICAgIGFuYWx5c2VzOiBDRk9BbmFseXNpc1tdO1xuICAgIG92ZXJhbGxTZW50aW1lbnQ6IE1hcmtldFNlbnRpbWVudDtcbiAgICB0b3BPcHBvcnR1bml0aWVzOiBzdHJpbmdbXTtcbiAgICB0b3BSaXNrczogc3RyaW5nW107XG4gICAgc3VtbWFyeTogc3RyaW5nO1xuICB9PiB7XG4gICAgLy8g5YiG5p6Q5Li76KaB5biB56eNXG4gICAgY29uc3Qgc3ltYm9scyA9IFtcIkJUQ1wiLCBcIkVUSFwiLCBcIkRPR0VcIiwgXCJTT0xcIl07XG4gICAgY29uc3QgYW5hbHlzZXMgPSBhd2FpdCB0aGlzLmFuYWx5emVNdWx0aXBsZShzeW1ib2xzKTtcblxuICAgIC8vIOiuoeeul+aVtOS9k+aDhee7qlxuICAgIGxldCBidWxsaXNoQ291bnQgPSAwO1xuICAgIGxldCBiZWFyaXNoQ291bnQgPSAwO1xuICAgIGxldCBuZXV0cmFsQ291bnQgPSAwO1xuICAgIGxldCBlcnJvckNvdW50ID0gMDtcblxuICAgIGNvbnN0IG9wcG9ydHVuaXRpZXM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3Qgcmlza3M6IHN0cmluZ1tdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGFuYWx5c2lzIG9mIGFuYWx5c2VzKSB7XG4gICAgICAvLyDot7Pov4fplJnor6/liIbmnpBcbiAgICAgIGlmIChhbmFseXNpcy5jb25zZW5zdXMuY29uZmlkZW5jZSA9PT0gMCAmJiBhbmFseXNpcy5wZXJzcGVjdGl2ZXMuYnVsbC5jb25maWRlbmNlID09PSAwKSB7XG4gICAgICAgIGVycm9yQ291bnQrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoYW5hbHlzaXMuY29uc2Vuc3VzLnNlbnRpbWVudCkge1xuICAgICAgICBjYXNlIFwiYnVsbGlzaFwiOlxuICAgICAgICAgIGJ1bGxpc2hDb3VudCsrO1xuICAgICAgICAgIGlmIChhbmFseXNpcy5jb25zZW5zdXMuY29uZmlkZW5jZSA+IDAuNikge1xuICAgICAgICAgICAgb3Bwb3J0dW5pdGllcy5wdXNoKGFuYWx5c2lzLnN5bWJvbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYmVhcmlzaFwiOlxuICAgICAgICAgIGJlYXJpc2hDb3VudCsrO1xuICAgICAgICAgIGlmIChhbmFseXNpcy5jb25zZW5zdXMuY29uZmlkZW5jZSA+IDAuNikge1xuICAgICAgICAgICAgcmlza3MucHVzaChhbmFseXNpcy5zeW1ib2wpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5ldXRyYWxcIjpcbiAgICAgICAgICBuZXV0cmFsQ291bnQrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZEFuYWx5c2VzID0gYW5hbHlzZXMubGVuZ3RoIC0gZXJyb3JDb3VudDtcblxuICAgIGxldCBvdmVyYWxsU2VudGltZW50OiBNYXJrZXRTZW50aW1lbnQ7XG4gICAgbGV0IHN1bW1hcnk6IHN0cmluZztcblxuICAgIGlmICh2YWxpZEFuYWx5c2VzID09PSAwKSB7XG4gICAgICBvdmVyYWxsU2VudGltZW50ID0gXCJuZXV0cmFsXCI7XG4gICAgICBzdW1tYXJ5ID0gXCLmlbDmja7liqDovb3lpLHotKXvvIzor7fnqI3lkI7liLfmlrDpobXpnaLph43or5XjgIJcIjtcbiAgICB9IGVsc2UgaWYgKGJ1bGxpc2hDb3VudCA+IGJlYXJpc2hDb3VudCAmJiBidWxsaXNoQ291bnQgPiBuZXV0cmFsQ291bnQpIHtcbiAgICAgIG92ZXJhbGxTZW50aW1lbnQgPSBcImJ1bGxpc2hcIjtcbiAgICAgIHN1bW1hcnkgPSBg5biC5Zy65ZGI546w55yL5rao5Yq/5aS077yMJHtidWxsaXNoQ291bnR9LyR7dmFsaWRBbmFseXNlc30g5Liq6LWE5Lqn5ZGI56ev5p6B5oCB5Yq/44CCYDtcbiAgICB9IGVsc2UgaWYgKGJlYXJpc2hDb3VudCA+IGJ1bGxpc2hDb3VudCAmJiBiZWFyaXNoQ291bnQgPiBuZXV0cmFsQ291bnQpIHtcbiAgICAgIG92ZXJhbGxTZW50aW1lbnQgPSBcImJlYXJpc2hcIjtcbiAgICAgIHN1bW1hcnkgPSBg5biC5Zy65om/5Y6L77yMJHtiZWFyaXNoQ291bnR9LyR7dmFsaWRBbmFseXNlc30g5Liq6LWE5Lqn5ZGI5raI5p6B5oCB5Yq/44CCYDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3ZlcmFsbFNlbnRpbWVudCA9IFwibmV1dHJhbFwiO1xuICAgICAgc3VtbWFyeSA9IGDluILlnLrkv6Hlj7fmt7fmnYLvvIwke25ldXRyYWxDb3VudH0vJHt2YWxpZEFuYWx5c2VzfSDkuKrotYTkuqflkYjkuK3mgKfmgIHlir/jgIJgO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhbmFseXNlcyxcbiAgICAgIG92ZXJhbGxTZW50aW1lbnQsXG4gICAgICB0b3BPcHBvcnR1bml0aWVzOiBvcHBvcnR1bml0aWVzLnNsaWNlKDAsIDMpLFxuICAgICAgdG9wUmlza3M6IHJpc2tzLnNsaWNlKDAsIDMpLFxuICAgICAgc3VtbWFyeSxcbiAgICB9O1xuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0g55Sf5oiQ5rSe5a+fID09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIOeUn+aIkCBDRk8g5rSe5a+fXG4gICAqL1xuICBnZW5lcmF0ZUluc2lnaHRzKGFuYWx5c2VzOiBDRk9BbmFseXNpc1tdKTogQ0ZPSW5zaWdodFtdIHtcbiAgICBjb25zdCBpbnNpZ2h0czogQ0ZPSW5zaWdodFtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGFuYWx5c2lzIG9mIGFuYWx5c2VzKSB7XG4gICAgICBjb25zdCB7IHN5bWJvbCwgY29uc2Vuc3VzLCBwZXJzcGVjdGl2ZXMgfSA9IGFuYWx5c2lzO1xuXG4gICAgICAvLyDlvLrkv6Hlj7fmtJ7lr59cbiAgICAgIGlmIChjb25zZW5zdXMuY29uZmlkZW5jZSA+IDAuNykge1xuICAgICAgICBpbnNpZ2h0cy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBjb25zZW5zdXMuc2VudGltZW50ID09PSBcImJ1bGxpc2hcIiA/IFwib3Bwb3J0dW5pdHlcIiA6IFwid2FybmluZ1wiLFxuICAgICAgICAgIHRpdGxlOiBgJHtzeW1ib2x9ICR7Y29uc2Vuc3VzLnNlbnRpbWVudCA9PT0gXCJidWxsaXNoXCIgPyBcIk9wcG9ydHVuaXR5XCIgOiBcIlJpc2sgQWxlcnRcIn1gLFxuICAgICAgICAgIGNvbnRlbnQ6IGNvbnNlbnN1cy5zdW1tYXJ5LFxuICAgICAgICAgIGNvbmZpZGVuY2U6IGNvbnNlbnN1cy5jb25maWRlbmNlLFxuICAgICAgICAgIHJlbGF0ZWRTeW1ib2xzOiBbc3ltYm9sXSxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyDop4LngrnliIbmrafmtJ7lr59cbiAgICAgIGNvbnN0IGJ1bGxDb25mID0gcGVyc3BlY3RpdmVzLmJ1bGwuY29uZmlkZW5jZTtcbiAgICAgIGNvbnN0IGJlYXJDb25mID0gcGVyc3BlY3RpdmVzLmJlYXIuY29uZmlkZW5jZTtcbiAgICAgIGlmIChNYXRoLmFicyhidWxsQ29uZiAtIGJlYXJDb25mKSA8IDAuMiAmJiBidWxsQ29uZiA+IDAuNCAmJiBiZWFyQ29uZiA+IDAuNCkge1xuICAgICAgICBpbnNpZ2h0cy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcIm1hcmtldF9vdXRsb29rXCIsXG4gICAgICAgICAgdGl0bGU6IGAke3N5bWJvbH0gYXQgQ3JpdGljYWwgSnVuY3R1cmVgLFxuICAgICAgICAgIGNvbnRlbnQ6IGBCdWxsIGNhc2UgKCR7KGJ1bGxDb25mICogMTAwKS50b0ZpeGVkKDApfSUgY29uZmlkZW5jZSkgdnMgQmVhciBjYXNlICgkeyhiZWFyQ29uZiAqIDEwMCkudG9GaXhlZCgwKX0lIGNvbmZpZGVuY2UpLiBNYXJrZXQgZGlyZWN0aW9uIHVuY2xlYXIuYCxcbiAgICAgICAgICBjb25maWRlbmNlOiAwLjUsXG4gICAgICAgICAgcmVsYXRlZFN5bWJvbHM6IFtzeW1ib2xdLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc2lnaHRzLnNvcnQoKGEsIGIpID0+IGIuY29uZmlkZW5jZSAtIGEuY29uZmlkZW5jZSk7XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSDln7rkuo4gRmVlZCDnmoTmmbrog73liKTmlq0gPT09PT09PT09PT09PT09PT09PT1cblxuICAvKipcbiAgICog5Z+65LqOIEZlZWQg5oOF5oql5YGa5Lqk5piT5Yaz562WXG4gICAqIOe7vOWQiOWIhuaekOaJgOaciSBBZ2VudCDlj5HluIPnmoTmg4XmiqXvvIznu5nlh7rkuqTmmJPlu7rorq5cbiAgICovXG4gIGFzeW5jIGFuYWx5emVGcm9tRmVlZChzeW1ib2xzPzogc3RyaW5nW10pOiBQcm9taXNlPHtcbiAgICBzeW1ib2w6IHN0cmluZztcbiAgICBhY3Rpb246IFwiYnV5XCIgfCBcInNlbGxcIiB8IFwiaG9sZFwiIHwgXCJ3YXRjaFwiO1xuICAgIGNvbmZpZGVuY2U6IG51bWJlcjtcbiAgICByZWFzb25pbmc6IHN0cmluZztcbiAgICBwb3NpdGlvbjoge1xuICAgICAgc2l6ZTogXCJzbWFsbFwiIHwgXCJtZWRpdW1cIiB8IFwibGFyZ2VcIjtcbiAgICAgIHBlcmNlbnRhZ2U6IG51bWJlcjsgLy8g5bu66K6u5LuT5L2N55m+5YiG5q+UXG4gICAgfTtcbiAgICBzdG9wTG9zcz86IG51bWJlcjtcbiAgICB0YWtlUHJvZml0PzogbnVtYmVyO1xuICAgIHRpbWVmcmFtZTogc3RyaW5nO1xuICB9W10+IHtcbiAgICBjb25zdCB0YXJnZXRTeW1ib2xzID0gc3ltYm9scyB8fCBbXCJCVENcIiwgXCJET0dFXCJdO1xuICAgIGNvbnN0IHJlY29tbWVuZGF0aW9uczogQXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiB0aGlzLmFuYWx5emVGcm9tRmVlZD4+ID0gW107XG5cbiAgICAvLyDojrflj5bmnIDov5HnmoTmg4XmiqXvvIgzMOWIhumSn+WGhe+8iVxuICAgIGNvbnN0IHJlY2VudEZlZWRzID0gZ2V0RmVlZEl0ZW1zKHsgbGltaXQ6IDUwIH0pO1xuICAgIGNvbnN0IHRoaXJ0eU1pbnV0ZXNBZ28gPSBEYXRlLm5vdygpIC0gMzAgKiA2MCAqIDEwMDA7XG4gICAgY29uc3QgcmVsZXZhbnRGZWVkcyA9IHJlY2VudEZlZWRzLmZpbHRlcihcbiAgICAgIGYgPT4gZi50aW1lc3RhbXAuZ2V0VGltZSgpID4gdGhpcnR5TWludXRlc0Fnb1xuICAgICk7XG5cbiAgICBmb3IgKGNvbnN0IHN5bWJvbCBvZiB0YXJnZXRTeW1ib2xzKSB7XG4gICAgICAvLyDnrZvpgInor6XluIHnp43nm7jlhbPnmoTmg4XmiqVcbiAgICAgIGNvbnN0IHN5bWJvbEZlZWRzID0gcmVsZXZhbnRGZWVkcy5maWx0ZXIoZiA9PiBcbiAgICAgICAgZi5zeW1ib2wgPT09IHN5bWJvbCB8fCBmLnRpdGxlLmluY2x1ZGVzKHN5bWJvbClcbiAgICAgICk7XG5cbiAgICAgIC8vIOWIhuexu+e7n+iuoVxuICAgICAgY29uc3QgdGVjaFNpZ25hbHMgPSBzeW1ib2xGZWVkcy5maWx0ZXIoZiA9PiBmLnR5cGUgPT09IFwidGVjaG5pY2FsX3NpZ25hbFwiKTtcbiAgICAgIGNvbnN0IHBhQW5hbHlzZXMgPSBzeW1ib2xGZWVkcy5maWx0ZXIoZiA9PiBmLnR5cGUgPT09IFwicGFfYW5hbHlzaXNcIik7XG4gICAgICBjb25zdCBzZW50aW1lbnRGZWVkcyA9IHN5bWJvbEZlZWRzLmZpbHRlcihmID0+IGYudHlwZSA9PT0gXCJzZW50aW1lbnRfc2hpZnRcIik7XG5cbiAgICAgIC8vIOiuoeeul+e7vOWQiOW+l+WIhlxuICAgICAgbGV0IGJ1bGxpc2hTY29yZSA9IDA7XG4gICAgICBsZXQgYmVhcmlzaFNjb3JlID0gMDtcbiAgICAgIGxldCB0b3RhbFdlaWdodCA9IDA7XG5cbiAgICAgIC8vIOaKgOacr+WIhuaekOadg+mHjSA0MCVcbiAgICAgIHRlY2hTaWduYWxzLmZvckVhY2goZmVlZCA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBmZWVkLmRhdGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgICAgIGlmIChkYXRhPy5zaWduYWxUeXBlID09PSBcImJ1eVwiIHx8IGRhdGE/LnNpZ25hbFR5cGUgPT09IFwic3Ryb25nX2J1eVwiKSB7XG4gICAgICAgICAgYnVsbGlzaFNjb3JlICs9IChkYXRhLnNpZ25hbENvbmZpZGVuY2UgYXMgbnVtYmVyIHx8IDAuNSkgKiAwLjQ7XG4gICAgICAgICAgdG90YWxXZWlnaHQgKz0gMC40O1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGE/LnNpZ25hbFR5cGUgPT09IFwic2VsbFwiIHx8IGRhdGE/LnNpZ25hbFR5cGUgPT09IFwic3Ryb25nX3NlbGxcIikge1xuICAgICAgICAgIGJlYXJpc2hTY29yZSArPSAoZGF0YS5zaWduYWxDb25maWRlbmNlIGFzIG51bWJlciB8fCAwLjUpICogMC40O1xuICAgICAgICAgIHRvdGFsV2VpZ2h0ICs9IDAuNDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFBBIOeglOWIpOadg+mHjSAzNSVcbiAgICAgIHBhQW5hbHlzZXMuZm9yRWFjaChmZWVkID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGZlZWQuZGF0YSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAgICAgY29uc3QgYnVsbENvbmYgPSAoZGF0YT8uYnVsbENvbmZpZGVuY2UgYXMgbnVtYmVyKSB8fCAwO1xuICAgICAgICBjb25zdCBiZWFyQ29uZiA9IChkYXRhPy5iZWFyQ29uZmlkZW5jZSBhcyBudW1iZXIpIHx8IDA7XG4gICAgICAgIGNvbnN0IGNvbnNlbnN1cyA9IGRhdGE/LmNvbnNlbnN1c1NlbnRpbWVudCBhcyBzdHJpbmc7XG4gICAgICAgIFxuICAgICAgICBpZiAoY29uc2Vuc3VzID09PSBcImJ1bGxpc2hcIikge1xuICAgICAgICAgIGJ1bGxpc2hTY29yZSArPSBidWxsQ29uZiAqIDAuMzU7XG4gICAgICAgICAgdG90YWxXZWlnaHQgKz0gMC4zNTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zZW5zdXMgPT09IFwiYmVhcmlzaFwiKSB7XG4gICAgICAgICAgYmVhcmlzaFNjb3JlICs9IGJlYXJDb25mICogMC4zNTtcbiAgICAgICAgICB0b3RhbFdlaWdodCArPSAwLjM1O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8g6aKE5rWL5biC5Zy65oOF57uq5p2D6YeNIDI1JVxuICAgICAgc2VudGltZW50RmVlZHMuZm9yRWFjaChmZWVkID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGZlZWQuZGF0YSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAgICAgY29uc3Qgc2VudGltZW50ID0gZGF0YT8uc2VudGltZW50IGFzIG51bWJlcjtcbiAgICAgICAgaWYgKHNlbnRpbWVudCA+IDAuNikge1xuICAgICAgICAgIGJ1bGxpc2hTY29yZSArPSBzZW50aW1lbnQgKiAwLjI1O1xuICAgICAgICAgIHRvdGFsV2VpZ2h0ICs9IDAuMjU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VudGltZW50IDwgMC40KSB7XG4gICAgICAgICAgYmVhcmlzaFNjb3JlICs9ICgxIC0gc2VudGltZW50KSAqIDAuMjU7XG4gICAgICAgICAgdG90YWxXZWlnaHQgKz0gMC4yNTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIOiuoeeul+e9ruS/oeW6puWSjOWGs+etllxuICAgICAgY29uc3QgY29uZmlkZW5jZSA9IHRvdGFsV2VpZ2h0ID4gMCA/IE1hdGguYWJzKGJ1bGxpc2hTY29yZSAtIGJlYXJpc2hTY29yZSkgLyB0b3RhbFdlaWdodCA6IDA7XG4gICAgICBsZXQgYWN0aW9uOiBcImJ1eVwiIHwgXCJzZWxsXCIgfCBcImhvbGRcIiB8IFwid2F0Y2hcIjtcbiAgICAgIGxldCByZWFzb25pbmcgPSBcIlwiO1xuICAgICAgbGV0IHBvc2l0aW9uU2l6ZTogXCJzbWFsbFwiIHwgXCJtZWRpdW1cIiB8IFwibGFyZ2VcIiA9IFwic21hbGxcIjtcbiAgICAgIGxldCBwZXJjZW50YWdlID0gMTA7XG5cbiAgICAgIGlmIChjb25maWRlbmNlIDwgMC4zKSB7XG4gICAgICAgIGFjdGlvbiA9IFwid2F0Y2hcIjtcbiAgICAgICAgcmVhc29uaW5nID0gYOS/oeWPt+S4jeaYjuehru+8jOW7uuiuruinguacm+OAguaKgOacr+S/oeWPtyR7dGVjaFNpZ25hbHMubGVuZ3RofeS4qu+8jFBB56CU5YikJHtwYUFuYWx5c2VzLmxlbmd0aH3kuKrjgIJgO1xuICAgICAgfSBlbHNlIGlmIChidWxsaXNoU2NvcmUgPiBiZWFyaXNoU2NvcmUpIHtcbiAgICAgICAgYWN0aW9uID0gY29uZmlkZW5jZSA+IDAuNyA/IFwiYnV5XCIgOiBcImhvbGRcIjtcbiAgICAgICAgcG9zaXRpb25TaXplID0gY29uZmlkZW5jZSA+IDAuOCA/IFwibGFyZ2VcIiA6IGNvbmZpZGVuY2UgPiAwLjYgPyBcIm1lZGl1bVwiIDogXCJzbWFsbFwiO1xuICAgICAgICBwZXJjZW50YWdlID0gTWF0aC5yb3VuZChjb25maWRlbmNlICogMzApOyAvLyDmnIDlpJozMCXku5PkvY1cbiAgICAgICAgcmVhc29uaW5nID0gYOe7vOWQiCR7dGVjaFNpZ25hbHMubGVuZ3RofeS4quaKgOacr+S/oeWPt+WSjCR7cGFBbmFseXNlcy5sZW5ndGh95LiqUEHnoJTliKTvvIznnIvmtqjlm6DntKDljaDkvJjjgIJgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9uID0gY29uZmlkZW5jZSA+IDAuNyA/IFwic2VsbFwiIDogXCJob2xkXCI7XG4gICAgICAgIHBvc2l0aW9uU2l6ZSA9IGNvbmZpZGVuY2UgPiAwLjggPyBcImxhcmdlXCIgOiBjb25maWRlbmNlID4gMC42ID8gXCJtZWRpdW1cIiA6IFwic21hbGxcIjtcbiAgICAgICAgcGVyY2VudGFnZSA9IE1hdGgucm91bmQoY29uZmlkZW5jZSAqIDI1KTtcbiAgICAgICAgcmVhc29uaW5nID0gYOe7vOWQiCR7dGVjaFNpZ25hbHMubGVuZ3RofeS4quaKgOacr+S/oeWPt+WSjCR7cGFBbmFseXNlcy5sZW5ndGh95LiqUEHnoJTliKTvvIznnIvot4zlm6DntKDljaDkvJjjgIJgO1xuICAgICAgfVxuXG4gICAgICAvLyDojrflj5blvZPliY3ku7fmoLznlKjkuo7orqHnrpfmraLmjZ/mraLnm4hcbiAgICAgIGNvbnN0IGN1cnJlbnRQcmljZSA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudFByaWNlKHN5bWJvbCk7XG4gICAgICBjb25zdCBzdG9wTG9zcyA9IGFjdGlvbiA9PT0gXCJidXlcIiA/IGN1cnJlbnRQcmljZSAqIDAuOTUgOiBhY3Rpb24gPT09IFwic2VsbFwiID8gY3VycmVudFByaWNlICogMS4wNSA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IHRha2VQcm9maXQgPSBhY3Rpb24gPT09IFwiYnV5XCIgPyBjdXJyZW50UHJpY2UgKiAxLjEgOiBhY3Rpb24gPT09IFwic2VsbFwiID8gY3VycmVudFByaWNlICogMC45IDogdW5kZWZpbmVkO1xuXG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCh7XG4gICAgICAgIHN5bWJvbCxcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBjb25maWRlbmNlOiBNYXRoLnJvdW5kKGNvbmZpZGVuY2UgKiAxMDApIC8gMTAwLFxuICAgICAgICByZWFzb25pbmcsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgc2l6ZTogcG9zaXRpb25TaXplLFxuICAgICAgICAgIHBlcmNlbnRhZ2UsXG4gICAgICAgIH0sXG4gICAgICAgIHN0b3BMb3NzLFxuICAgICAgICB0YWtlUHJvZml0LFxuICAgICAgICB0aW1lZnJhbWU6IFwi55+t5pyf77yIMS0z5aSp77yJXCIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjb21tZW5kYXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIOiOt+WPluW9k+WJjeS7t+agvO+8iOeugOWMlueJiO+8jOWunumZheW6lOS7jue8k+WtmOaIlkFQSeiOt+WPlu+8iVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXRDdXJyZW50UHJpY2Uoc3ltYm9sOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IG1vY2tQcmljZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XG4gICAgICBCVEM6IDUwMDAwLFxuICAgICAgRE9HRTogMC4xNSxcbiAgICAgIEVUSDogMzAwMCxcbiAgICAgIFNPTDogMTAwLFxuICAgIH07XG4gICAgcmV0dXJuIG1vY2tQcmljZXNbc3ltYm9sXSB8fCAxMDA7XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSDkuqTmmJPmiafooYzvvIjnroDljZXnm7TmjqXvvIk9PT09PT09PT09PT09PT09PT09PVxuXG4gIC8vIE1vY2sg5Lu35qC877yI5a6e6ZmF55Sf5Lqn546v5aKD5bqU5LuOIENvaW5HZWNrbyDojrflj5bvvIlcbiAgcHJpdmF0ZSBtb2NrUHJpY2VzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xuICAgIEJUQzogNjg0MDAsXG4gICAgRE9HRTogMC4xMCxcbiAgICBFVEg6IDM1MDAsXG4gICAgU09MOiAxNTAsXG4gICAgWFJQOiAwLjYsXG4gICAgQURBOiAwLjQsXG4gIH07XG5cbiAgLyoqXG4gICAqIOaJp+ihjOS6pOaYk1xuICAgKiDnm7TmjqXosIPnlKggUG9ydGZvbGlv77yM5LiN5YGa5aSN5p2C6aOO5o6n77yI6aOO5o6n55SxIFBBIOWGs+etluaXtuaOp+WItu+8iVxuICAgKi9cbiAgYXN5bmMgZXhlY3V0ZVRyYWRlKHBhcmFtczoge1xuICAgIHN5bWJvbDogc3RyaW5nO1xuICAgIHNpZGU6ICdidXknIHwgJ3NlbGwnO1xuICAgIGFtb3VudD86IG51bWJlcjsgICAgICAvLyDkubDlhaXph5Hpop0gKFVTRClcbiAgICBxdWFudGl0eT86IG51bWJlcjsgICAgLy8g5Y2W5Ye65pWw6YePXG4gICAgcmVhc29uPzogc3RyaW5nO1xuICB9KTogUHJvbWlzZTx7XG4gICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICB0cmFkZT86IHtcbiAgICAgIGlkOiBzdHJpbmc7XG4gICAgICBzeW1ib2w6IHN0cmluZztcbiAgICAgIHNpZGU6IHN0cmluZztcbiAgICAgIHF1YW50aXR5OiBudW1iZXI7XG4gICAgICBwcmljZTogbnVtYmVyO1xuICAgICAgdG90YWw6IG51bWJlcjtcbiAgICAgIGZlZTogbnVtYmVyO1xuICAgIH07XG4gICAgcG9ydGZvbGlvPzoge1xuICAgICAgdG90YWxFcXVpdHk6IG51bWJlcjtcbiAgICAgIGJhbGFuY2U6IG51bWJlcjtcbiAgICAgIHBvc2l0aW9uczogeyBzeW1ib2w6IHN0cmluZzsgcXVhbnRpdHk6IG51bWJlcjsgYXZnUHJpY2U6IG51bWJlciB9W107XG4gICAgfTtcbiAgICBlcnJvcj86IHN0cmluZztcbiAgfT4ge1xuICAgIGNvbnN0IHBvcnRmb2xpbyA9IGdldFBvcnRmb2xpb01hbmFnZXIoKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyDkubDlhaXpnIDopoEgYW1vdW5077yM5Y2W5Ye66ZyA6KaBIHF1YW50aXR5XG4gICAgICBpZiAocGFyYW1zLnNpZGUgPT09ICdidXknICYmICFwYXJhbXMuYW1vdW50KSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ+S5sOWFpeW/hemhu+aPkOS+myBhbW91bnQgKFVTRCknIH07XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnNpZGUgPT09ICdzZWxsJyAmJiAhcGFyYW1zLnF1YW50aXR5KSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ+WNluWHuuW/hemhu+aPkOS+myBxdWFudGl0eScgfTtcbiAgICAgIH1cblxuICAgICAgLy8g6I635Y+W5b2T5YmN5Lu35qC86K6h566X5pWw6YePXG4gICAgICBsZXQgcXVhbnRpdHkgPSBwYXJhbXMucXVhbnRpdHkgfHwgMDtcbiAgICAgIGNvbnN0IHByaWNlID0gdGhpcy5tb2NrUHJpY2VzW3BhcmFtcy5zeW1ib2wudG9VcHBlckNhc2UoKV0gfHwgMTAwO1xuICAgICAgXG4gICAgICBpZiAocGFyYW1zLnNpZGUgPT09ICdidXknICYmIHBhcmFtcy5hbW91bnQpIHtcbiAgICAgICAgcXVhbnRpdHkgPSBwYXJhbXMuYW1vdW50IC8gcHJpY2U7XG4gICAgICB9XG5cbiAgICAgIC8vIOaJp+ihjOS6pOaYk1xuICAgICAgY29uc3QgcmVzdWx0ID0gcG9ydGZvbGlvLmV4ZWN1dGVUcmFkZSh7XG4gICAgICAgIHN5bWJvbDogcGFyYW1zLnN5bWJvbC50b1VwcGVyQ2FzZSgpLFxuICAgICAgICBzaWRlOiBwYXJhbXMuc2lkZSxcbiAgICAgICAgdHlwZTogJ21hcmtldCcsXG4gICAgICAgIHF1YW50aXR5LFxuICAgICAgICBwcmljZSwgIC8vIOS8oOWFpeS7t+agvFxuICAgICAgICBub3RlczogcGFyYW1zLnJlYXNvbiB8fCBgJHtwYXJhbXMuc2lkZS50b1VwcGVyQ2FzZSgpfSAke3BhcmFtcy5zeW1ib2x9YCxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcmVzdWx0LmVycm9yIH07XG4gICAgICB9XG5cbiAgICAgIC8vIOiOt+WPluabtOaWsOWQjueahCBQb3J0Zm9saW9cbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBwb3J0Zm9saW8uZ2V0UG9ydGZvbGlvKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHRyYWRlOiByZXN1bHQudHJhZGUgPyB7XG4gICAgICAgICAgaWQ6IHJlc3VsdC50cmFkZS5pZCxcbiAgICAgICAgICBzeW1ib2w6IHJlc3VsdC50cmFkZS5zeW1ib2wsXG4gICAgICAgICAgc2lkZTogcmVzdWx0LnRyYWRlLnNpZGUsXG4gICAgICAgICAgcXVhbnRpdHk6IHJlc3VsdC50cmFkZS5xdWFudGl0eSxcbiAgICAgICAgICBwcmljZTogcmVzdWx0LnRyYWRlLnByaWNlLFxuICAgICAgICAgIHRvdGFsOiByZXN1bHQudHJhZGUudG90YWwsXG4gICAgICAgICAgZmVlOiByZXN1bHQudHJhZGUuZmVlLFxuICAgICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgICBwb3J0Zm9saW86IHtcbiAgICAgICAgICB0b3RhbEVxdWl0eTogY3VycmVudC50b3RhbEVxdWl0eSxcbiAgICAgICAgICBiYWxhbmNlOiBjdXJyZW50LmJhbGFuY2UsXG4gICAgICAgICAgcG9zaXRpb25zOiBjdXJyZW50LnBvc2l0aW9ucy5tYXAocCA9PiAoe1xuICAgICAgICAgICAgc3ltYm9sOiBwLnN5bWJvbCxcbiAgICAgICAgICAgIHF1YW50aXR5OiBwLnF1YW50aXR5LFxuICAgICAgICAgICAgYXZnUHJpY2U6IHAuYXZnUHJpY2UsXG4gICAgICAgICAgfSkpLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ+S6pOaYk+aJp+ihjOWksei0pScsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiDkuIDplK7liIbmnpDlubbmiafooYzkuqTmmJNcbiAgICovXG4gIGFzeW5jIGFuYWx5emVBbmRUcmFkZShcbiAgICBzeW1ib2xzPzogc3RyaW5nW10sXG4gICAgYXV0b0V4ZWN1dGU6IGJvb2xlYW4gPSBmYWxzZVxuICApOiBQcm9taXNlPHtcbiAgICBhbmFseXNlczoge1xuICAgICAgc3ltYm9sOiBzdHJpbmc7XG4gICAgICBhY3Rpb246IFwiYnV5XCIgfCBcInNlbGxcIiB8IFwiaG9sZFwiIHwgXCJ3YXRjaFwiO1xuICAgICAgY29uZmlkZW5jZTogbnVtYmVyO1xuICAgICAgcmVhc29uaW5nOiBzdHJpbmc7XG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICBzaXplOiBcInNtYWxsXCIgfCBcIm1lZGl1bVwiIHwgXCJsYXJnZVwiO1xuICAgICAgICBwZXJjZW50YWdlOiBudW1iZXI7XG4gICAgICB9O1xuICAgICAgc3RvcExvc3M/OiBudW1iZXI7XG4gICAgICB0YWtlUHJvZml0PzogbnVtYmVyO1xuICAgICAgdGltZWZyYW1lOiBzdHJpbmc7XG4gICAgfVtdO1xuICAgIGV4ZWN1dGlvbnM/OiB7XG4gICAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgICAgdHJhZGU/OiB7XG4gICAgICAgIGlkOiBzdHJpbmc7XG4gICAgICAgIHN5bWJvbDogc3RyaW5nO1xuICAgICAgICBzaWRlOiBzdHJpbmc7XG4gICAgICAgIHF1YW50aXR5OiBudW1iZXI7XG4gICAgICAgIHByaWNlOiBudW1iZXI7XG4gICAgICAgIHRvdGFsOiBudW1iZXI7XG4gICAgICAgIGZlZTogbnVtYmVyO1xuICAgICAgfTtcbiAgICAgIHBvcnRmb2xpbz86IHtcbiAgICAgICAgdG90YWxFcXVpdHk6IG51bWJlcjtcbiAgICAgICAgYmFsYW5jZTogbnVtYmVyO1xuICAgICAgICBwb3NpdGlvbnM6IHsgc3ltYm9sOiBzdHJpbmc7IHF1YW50aXR5OiBudW1iZXI7IGF2Z1ByaWNlOiBudW1iZXIgfVtdO1xuICAgICAgfTtcbiAgICAgIGVycm9yPzogc3RyaW5nO1xuICAgIH1bXTtcbiAgfT4ge1xuICAgIC8vIDEuIOWIhuaekFxuICAgIGNvbnN0IGFuYWx5c2VzID0gYXdhaXQgdGhpcy5hbmFseXplRnJvbUZlZWQoc3ltYm9scyk7XG4gICAgXG4gICAgLy8gMi4g5aaC5p6c5ZCv55So6Ieq5Yqo5omn6KGM77yM5omn6KGM5Lqk5piTXG4gICAgY29uc3QgZXhlY3V0aW9uczogQXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiB0aGlzLmV4ZWN1dGVUcmFkZT4+W10gPSBbXTtcbiAgICBcbiAgICBpZiAoYXV0b0V4ZWN1dGUpIHtcbiAgICAgIGZvciAoY29uc3QgcmVjIG9mIGFuYWx5c2VzKSB7XG4gICAgICAgIC8vIOWPquaJp+ihjCBidXkvc2VsbO+8jOi3s+i/hyBob2xkL3dhdGNoXG4gICAgICAgIGlmIChyZWMuYWN0aW9uID09PSAnYnV5JyB8fCByZWMuYWN0aW9uID09PSAnc2VsbCcpIHtcbiAgICAgICAgICAvLyDmoLnmja7lu7rorq7ku5PkvY3orqHnrpfph5Hpop1cbiAgICAgICAgICBjb25zdCBwb3J0Zm9saW8gPSBnZXRQb3J0Zm9saW9NYW5hZ2VyKCk7XG4gICAgICAgICAgY29uc3QgZXF1aXR5ID0gcG9ydGZvbGlvLmdldFBvcnRmb2xpbygpLnRvdGFsRXF1aXR5O1xuICAgICAgICAgIGNvbnN0IGFtb3VudCA9IChlcXVpdHkgKiByZWMucG9zaXRpb24ucGVyY2VudGFnZSkgLyAxMDA7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dGVUcmFkZSh7XG4gICAgICAgICAgICBzeW1ib2w6IHJlYy5zeW1ib2wsXG4gICAgICAgICAgICBzaWRlOiByZWMuYWN0aW9uLFxuICAgICAgICAgICAgYW1vdW50OiByZWMuYWN0aW9uID09PSAnYnV5JyA/IGFtb3VudCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHF1YW50aXR5OiByZWMuYWN0aW9uID09PSAnc2VsbCcgPyByZWMucG9zaXRpb24ucGVyY2VudGFnZSA6IHVuZGVmaW5lZCwgLy8g6L+Z6YeM566A5YyW5aSE55CGXG4gICAgICAgICAgICByZWFzb246IHJlYy5yZWFzb25pbmcsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgZXhlY3V0aW9ucy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBhbmFseXNlcywgZXhlY3V0aW9ucyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIOagvOW8j+WMliBGZWVkIOWIhuaekOS4uuS6pOaYk+W7uuiurlxuICAgKi9cbiAgZm9ybWF0VHJhZGVSZWNvbW1lbmRhdGlvbihyZWM6IEF3YWl0ZWQ8UmV0dXJuVHlwZTx0eXBlb2YgdGhpcy5hbmFseXplRnJvbUZlZWQ+PlswXSk6IHN0cmluZyB7XG4gICAgY29uc3QgYWN0aW9uRW1vamkgPSByZWMuYWN0aW9uID09PSBcImJ1eVwiID8gXCLwn5+iIOS5sOWFpVwiIDogcmVjLmFjdGlvbiA9PT0gXCJzZWxsXCIgPyBcIvCflLQg5Y2W5Ye6XCIgOiByZWMuYWN0aW9uID09PSBcImhvbGRcIiA/IFwi8J+foSDmjIHmnIlcIiA6IFwi4pqqIOinguacm1wiO1xuICAgIGNvbnN0IHNpemVUZXh0ID0gcmVjLnBvc2l0aW9uLnNpemUgPT09IFwibGFyZ2VcIiA/IFwi6YeN5LuTXCIgOiByZWMucG9zaXRpb24uc2l6ZSA9PT0gXCJtZWRpdW1cIiA/IFwi5Lit5LuTXCIgOiBcIui9u+S7k1wiO1xuICAgIFxuICAgIGxldCByZXNwb25zZSA9IGAqKiR7cmVjLnN5bWJvbH0g5Lqk5piT5bu66K6uKipcXG5cXG5gO1xuICAgIHJlc3BvbnNlICs9IGAke2FjdGlvbkVtb2ppfSB8IOe9ruS/oeW6pjogJHsocmVjLmNvbmZpZGVuY2UgKiAxMDApLnRvRml4ZWQoMCl9JVxcbmA7XG4gICAgcmVzcG9uc2UgKz0gYOW7uuiuruS7k+S9jTogJHtzaXplVGV4dH0gKCR7cmVjLnBvc2l0aW9uLnBlcmNlbnRhZ2V9JSlcXG5cXG5gO1xuICAgIHJlc3BvbnNlICs9IGDwn5KhICoq5Yik5pat5L6d5o2uKio6ICR7cmVjLnJlYXNvbmluZ31cXG5cXG5gO1xuICAgIFxuICAgIGlmIChyZWMuc3RvcExvc3MgJiYgcmVjLnRha2VQcm9maXQpIHtcbiAgICAgIHJlc3BvbnNlICs9IGDwn5uRIOatouaNnzogJCR7cmVjLnN0b3BMb3NzLnRvRml4ZWQocmVjLnN5bWJvbCA9PT0gXCJET0dFXCIgPyA0IDogMCl9XFxuYDtcbiAgICAgIHJlc3BvbnNlICs9IGDwn46vIOatouebiDogJCR7cmVjLnRha2VQcm9maXQudG9GaXhlZChyZWMuc3ltYm9sID09PSBcIkRPR0VcIiA/IDQgOiAwKX1cXG5gO1xuICAgIH1cbiAgICBcbiAgICByZXNwb25zZSArPSBg4o+wIOaXtumXtOahhuaetjogJHtyZWMudGltZWZyYW1lfWA7XG4gICAgXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0g5qC85byP5YyW6L6T5Ye6ID09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIOagvOW8j+WMluWIhuaekOe7k+aenOS4uuWvueivneWbnuWkjVxuICAgKi9cbiAgZm9ybWF0QW5hbHlzaXNGb3JDaGF0KGFuYWx5c2lzOiBDRk9BbmFseXNpcyk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBzeW1ib2wsIGNvbnNlbnN1cywgcGVyc3BlY3RpdmVzLCB0ZWNobmljYWxEYXRhIH0gPSBhbmFseXNpcztcblxuICAgIC8vIOWmguaenOaYr+mUmeivr+WIhuaekO+8jOi/lOWbnueugOa0gemUmeivr+S/oeaBr1xuICAgIGlmIChhbmFseXNpcy5jb25zZW5zdXMuY29uZmlkZW5jZSA9PT0gMCAmJiBhbmFseXNpcy5wZXJzcGVjdGl2ZXMuYnVsbC5jb25maWRlbmNlID09PSAwKSB7XG4gICAgICByZXR1cm4gYPCfk4ogKioke3N5bWJvbH0g5YiG5p6Q5oql5ZGKKipcXG5cXG4ke2FuYWx5c2lzLmNvbnNlbnN1cy5zdW1tYXJ5fWA7XG4gICAgfVxuXG4gICAgbGV0IHJlc3BvbnNlID0gYPCfk4ogKioke3N5bWJvbH0g5YiG5p6Q5oql5ZGKKipcXG5cXG5gO1xuXG4gICAgLy8g5oqA5pyv5oyH5qCH5qaC6KeIXG4gICAgcmVzcG9uc2UgKz0gYCoq5oqA5pyv5oyH5qCH77yaKipcXG5gO1xuICAgIHJlc3BvbnNlICs9IGAtIFJTSTogJHt0ZWNobmljYWxEYXRhLmluZGljYXRvcnMucnNpfVxcbmA7XG4gICAgcmVzcG9uc2UgKz0gYC0gTUE3OiAkJHt0ZWNobmljYWxEYXRhLmluZGljYXRvcnMubWE3LnRvTG9jYWxlU3RyaW5nKCl9XFxuYDtcbiAgICByZXNwb25zZSArPSBgLSBNQTE0OiAkJHt0ZWNobmljYWxEYXRhLmluZGljYXRvcnMubWExNC50b0xvY2FsZVN0cmluZygpfVxcbmA7XG4gICAgcmVzcG9uc2UgKz0gYC0g6LaL5Yq/OiAke3RlY2huaWNhbERhdGEuaW5kaWNhdG9ycy50cmVuZCA9PT0gJ3VwJyA/ICfkuIrmtqgnIDogdGVjaG5pY2FsRGF0YS5pbmRpY2F0b3JzLnRyZW5kID09PSAnZG93bicgPyAn5LiL6LeMJyA6ICfmqKrnm5gnfVxcblxcbmA7XG5cbiAgICAvLyBCdWxsIENhc2VcbiAgICByZXNwb25zZSArPSBg8J+QgiAqKueci+a2qOingueCuSoqICgkeyhwZXJzcGVjdGl2ZXMuYnVsbC5jb25maWRlbmNlICogMTAwKS50b0ZpeGVkKDApfSUg572u5L+h5bqmKVxcbmA7XG4gICAgcGVyc3BlY3RpdmVzLmJ1bGwua2V5UG9pbnRzLnNsaWNlKDAsIDIpLmZvckVhY2gocG9pbnQgPT4ge1xuICAgICAgcmVzcG9uc2UgKz0gYC0gJHtwb2ludH1cXG5gO1xuICAgIH0pO1xuICAgIHJlc3BvbnNlICs9IGBcXG5gO1xuXG4gICAgLy8gQmVhciBDYXNlXG4gICAgcmVzcG9uc2UgKz0gYPCfkLsgKirnnIvot4zop4LngrkqKiAoJHsocGVyc3BlY3RpdmVzLmJlYXIuY29uZmlkZW5jZSAqIDEwMCkudG9GaXhlZCgwKX0lIOe9ruS/oeW6pilcXG5gO1xuICAgIHBlcnNwZWN0aXZlcy5iZWFyLmtleVBvaW50cy5zbGljZSgwLCAyKS5mb3JFYWNoKHBvaW50ID0+IHtcbiAgICAgIHJlc3BvbnNlICs9IGAtICR7cG9pbnR9XFxuYDtcbiAgICB9KTtcbiAgICByZXNwb25zZSArPSBgXFxuYDtcblxuICAgIC8vIOe7k+iuulxuICAgIGNvbnN0IGVtb2ppID0gY29uc2Vuc3VzLmFjdGlvbiA9PT0gXCJidXlcIiA/IFwi8J+folwiIDogY29uc2Vuc3VzLmFjdGlvbiA9PT0gXCJzZWxsXCIgPyBcIvCflLRcIiA6IFwi8J+foVwiO1xuICAgIGNvbnN0IGFjdGlvblRleHQgPSBjb25zZW5zdXMuYWN0aW9uID09PSBcImJ1eVwiID8gXCLkubDlhaVcIiA6IGNvbnNlbnN1cy5hY3Rpb24gPT09IFwic2VsbFwiID8gXCLljZblh7pcIiA6IGNvbnNlbnN1cy5hY3Rpb24gPT09IFwid2F0Y2hcIiA/IFwi6KeC5pybXCIgOiBcIuaMgeaciVwiO1xuICAgIHJlc3BvbnNlICs9IGAke2Vtb2ppfSAqKkNGTyDlu7rorq46ICR7YWN0aW9uVGV4dH0qKlxcbmA7XG4gICAgcmVzcG9uc2UgKz0gYOe9ruS/oeW6pjogJHsoY29uc2Vuc3VzLmNvbmZpZGVuY2UgKiAxMDApLnRvRml4ZWQoMCl9JSB8IOaDhee7qjogJHtjb25zZW5zdXMuc2VudGltZW50ID09PSAnYnVsbGlzaCcgPyAn55yL5raoJyA6IGNvbnNlbnN1cy5zZW50aW1lbnQgPT09ICdiZWFyaXNoJyA/ICfnnIvot4wnIDogJ+S4reaApyd9XFxuYDtcbiAgICByZXNwb25zZSArPSBgPiAke2NvbnNlbnN1cy5zdW1tYXJ5fWA7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICAvKipcbiAgICog5qC85byP5YyW5biC5Zy65qaC6KeIXG4gICAqL1xuICBmb3JtYXRNYXJrZXRPdmVydmlldyhvdmVydmlldzoge1xuICAgIGFuYWx5c2VzOiBDRk9BbmFseXNpc1tdO1xuICAgIG92ZXJhbGxTZW50aW1lbnQ6IE1hcmtldFNlbnRpbWVudDtcbiAgICB0b3BPcHBvcnR1bml0aWVzOiBzdHJpbmdbXTtcbiAgICB0b3BSaXNrczogc3RyaW5nW107XG4gICAgc3VtbWFyeTogc3RyaW5nO1xuICB9KTogc3RyaW5nIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBg8J+MjSAqKuW4guWcuuamguiniCoqXFxuXFxuYDtcblxuICAgIGNvbnN0IHNlbnRpbWVudFRleHQgPSBvdmVydmlldy5vdmVyYWxsU2VudGltZW50ID09PSAnYnVsbGlzaCcgPyAn55yL5raoJyA6IG92ZXJ2aWV3Lm92ZXJhbGxTZW50aW1lbnQgPT09ICdiZWFyaXNoJyA/ICfnnIvot4wnIDogJ+S4reaApyc7XG4gICAgcmVzcG9uc2UgKz0gYCoq5pW05L2T5oOF57uq77yaKiogJHtzZW50aW1lbnRUZXh0fVxcbmA7XG4gICAgcmVzcG9uc2UgKz0gYCR7b3ZlcnZpZXcuc3VtbWFyeX1cXG5cXG5gO1xuXG4gICAgaWYgKG92ZXJ2aWV3LnRvcE9wcG9ydHVuaXRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzcG9uc2UgKz0gYPCfn6IgKirmnLrkvJrvvJoqKiAke292ZXJ2aWV3LnRvcE9wcG9ydHVuaXRpZXMuam9pbihcIiwgXCIpfVxcbmA7XG4gICAgfVxuXG4gICAgaWYgKG92ZXJ2aWV3LnRvcFJpc2tzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3BvbnNlICs9IGDwn5S0ICoq6aOO6Zmp77yaKiogJHtvdmVydmlldy50b3BSaXNrcy5qb2luKFwiLCBcIil9XFxuYDtcbiAgICB9XG5cbiAgICByZXNwb25zZSArPSBgXFxuKirotYTkuqfmkZjopoHvvJoqKlxcbmA7XG4gICAgZm9yIChjb25zdCBhbmFseXNpcyBvZiBvdmVydmlldy5hbmFseXNlcykge1xuICAgICAgY29uc3QgZW1vamkgPSBhbmFseXNpcy5jb25zZW5zdXMuc2VudGltZW50ID09PSBcImJ1bGxpc2hcIiA/IFwi8J+folwiIDogYW5hbHlzaXMuY29uc2Vuc3VzLnNlbnRpbWVudCA9PT0gXCJiZWFyaXNoXCIgPyBcIvCflLRcIiA6IFwi4pqqXCI7XG4gICAgICBjb25zdCBhY3Rpb25UZXh0ID0gYW5hbHlzaXMuY29uc2Vuc3VzLmFjdGlvbiA9PT0gXCJidXlcIiA/IFwi5Lmw5YWlXCIgOiBhbmFseXNpcy5jb25zZW5zdXMuYWN0aW9uID09PSBcInNlbGxcIiA/IFwi5Y2W5Ye6XCIgOiBhbmFseXNpcy5jb25zZW5zdXMuYWN0aW9uID09PSBcIndhdGNoXCIgPyBcIuinguacm1wiIDogXCLmjIHmnIlcIjtcbiAgICAgIHJlc3BvbnNlICs9IGAke2Vtb2ppfSAke2FuYWx5c2lzLnN5bWJvbH06ICR7YWN0aW9uVGV4dH0gKCR7KGFuYWx5c2lzLmNvbnNlbnN1cy5jb25maWRlbmNlICogMTAwKS50b0ZpeGVkKDApfSUpXFxuYDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSDnvJPlrZjnrqHnkIYgPT09PT09PT09PT09PT09PT09PT1cblxuICBwcml2YXRlIGNhY2hlQW5hbHlzaXMoYW5hbHlzaXM6IENGT0FuYWx5c2lzKTogdm9pZCB7XG4gICAgdGhpcy5yZWNlbnRBbmFseXNlcy5zZXQoYW5hbHlzaXMuc3ltYm9sLCBhbmFseXNpcyk7XG5cbiAgICAvLyDkv53mjIHnvJPlrZjlpKflsI/pmZDliLZcbiAgICBpZiAodGhpcy5yZWNlbnRBbmFseXNlcy5zaXplID4gdGhpcy5tYXhDYWNoZVNpemUpIHtcbiAgICAgIGNvbnN0IGZpcnN0S2V5ID0gdGhpcy5yZWNlbnRBbmFseXNlcy5rZXlzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgaWYgKGZpcnN0S2V5KSB7XG4gICAgICAgIHRoaXMucmVjZW50QW5hbHlzZXMuZGVsZXRlKGZpcnN0S2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRDYWNoZWRBbmFseXNpcyhzeW1ib2w6IHN0cmluZyk6IENGT0FuYWx5c2lzIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5yZWNlbnRBbmFseXNlcy5nZXQoc3ltYm9sKTtcbiAgfVxuXG4gIGdldEFsbENhY2hlZEFuYWx5c2VzKCk6IENGT0FuYWx5c2lzW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucmVjZW50QW5hbHlzZXMudmFsdWVzKCkpO1xuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0g5a6e546w5oq96LGh5pa55rOVID09PT09PT09PT09PT09PT09PT09XG5cbiAgYXN5bmMgZXhlY3V0ZVRhc2s8VD4odGFzazogQWdlbnRUYXNrKTogUHJvbWlzZTxUPiB7XG4gICAgY29uc3QgZGF0YSA9IHRhc2suZGF0YSBhcyBDRk9UYXNrO1xuXG4gICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJzaW5nbGVfYW5hbHlzaXNcIjoge1xuICAgICAgICBpZiAoIWRhdGEuc3ltYm9sKSB0aHJvdyBuZXcgRXJyb3IoXCLljZXmrKHliIbmnpDpnIDopoHmjIflrprluIHnp41cIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuYW5hbHl6ZVN5bWJvbChkYXRhLnN5bWJvbCk7XG4gICAgICAgIHJldHVybiByZXN1bHQgYXMgVDtcbiAgICAgIH1cblxuICAgICAgY2FzZSBcIm1hcmtldF9vdmVydmlld1wiOiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0TWFya2V0T3ZlcnZpZXcoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCBhcyBUO1xuICAgICAgfVxuXG4gICAgICBjYXNlIFwicG9ydGZvbGlvX3Jldmlld1wiOiB7XG4gICAgICAgIGNvbnN0IHN5bWJvbHMgPSBkYXRhLnBvcnRmb2xpbz8ubWFwKHAgPT4gcC5zeW1ib2wpIHx8IFtcIkJUQ1wiLCBcIkVUSFwiXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5hbmFseXplTXVsdGlwbGUoc3ltYm9scyk7XG4gICAgICAgIHJldHVybiByZXN1bHQgYXMgVDtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGDmnKrnn6XnmoQgQ0ZPIOS7u+WKoeexu+WeizogJHtkYXRhLnR5cGV9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGdlbmVyYXRlUmVzcG9uc2UoXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGxvd2VyTXNnID0gbWVzc2FnZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8g5biC5Zy65qaC6KeI6K+35rGCXG4gICAgaWYgKGxvd2VyTXNnLmluY2x1ZGVzKFwib3ZlcnZpZXdcIikgfHwgbG93ZXJNc2cuaW5jbHVkZXMoXCJtYXJrZXRcIikgfHwgbG93ZXJNc2cuaW5jbHVkZXMoXCLmpoLop4hcIikgfHwgbG93ZXJNc2cuaW5jbHVkZXMoXCLluILlnLpcIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG92ZXJ2aWV3ID0gYXdhaXQgdGhpcy5nZXRNYXJrZXRPdmVydmlldygpO1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRNYXJrZXRPdmVydmlldyhvdmVydmlldyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gXCLojrflj5bluILlnLrmpoLop4jml7bpgYfliLDpl67popjvvIzor7fnqI3lkI7lho3or5XjgIJcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDnibnlrprluIHnp43liIbmnpBcbiAgICBjb25zdCBzeW1ib2xNYXRjaCA9IG1lc3NhZ2UubWF0Y2goL1xcYihCVEN8RE9HRXxFVEh8U09MfFhSUHxBREF8QVZBWHxET1QpXFxiL2kpO1xuICAgIGlmIChzeW1ib2xNYXRjaCkge1xuICAgICAgY29uc3Qgc3ltYm9sID0gc3ltYm9sTWF0Y2hbMF0udG9VcHBlckNhc2UoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIOWFiOajgOafpee8k+WtmFxuICAgICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmdldENhY2hlZEFuYWx5c2lzKHN5bWJvbCk7XG4gICAgICAgIGlmIChjYWNoZWQgJiYgRGF0ZS5ub3coKSAtIGNhY2hlZC50aW1lc3RhbXAuZ2V0VGltZSgpIDwgNSAqIDYwICogMTAwMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdEFuYWx5c2lzRm9yQ2hhdChjYWNoZWQpICsgXCJcXG5cXG4qKOe8k+WtmOaVsOaNrikqXCI7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhbmFseXNpcyA9IGF3YWl0IHRoaXMuYW5hbHl6ZVN5bWJvbChzeW1ib2wpO1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRBbmFseXNpc0ZvckNoYXQoYW5hbHlzaXMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNc2cgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICcnO1xuICAgICAgICBpZiAoZXJyb3JNc2cuaW5jbHVkZXMoJzQyOScpKSB7XG4gICAgICAgICAgcmV0dXJuIGDij7MgQVBJIOivt+axgui/h+S6jumikee5ge+8jOivt+etieW+hSAxLTIg5YiG6ZKf5ZCO5YaN6K+V44CCYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYOaaguaXtuaXoOazleWIhuaekCAke3N5bWJvbH3vvIzluILlnLrmlbDmja7lj6/og73mmoLml7bkuI3lj6/nlKjjgIJgO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIOm7mOiupOWbnuWkjVxuICAgIHJldHVybiBg5oiR5piv5L2g55qEIENGTyDmmbrog73liqnmiYvvvIzlj6/ku6XluK7kvaDvvJpcXG5cXG5gICtcbiAgICAgIGDwn5OKICoq5biC5Zy65YiG5p6QKiogLSDor6Lpl64gQlRD44CBRE9HReOAgUVUSCDnrYnluIHnp41cXG5gICtcbiAgICAgIGDwn4yNICoq5biC5Zy65qaC6KeIKiogLSDovpPlhaVcIuW4guWcuuamguiniFwi5p+l55yL5pW05L2T5biC5Zy654q25Ya1XFxuYCArXG4gICAgICBg8J+SoSAqKuaKlei1hOW7uuiurioqIC0g5o+Q5L6b5Lmw5YWlL+WNluWHui/mjIHmnInlu7rorq5cXG5cXG5gICtcbiAgICAgIGDkvaDmg7PliIbmnpDku4DkuYjvvJ9gO1xuICB9XG59XG5cbi8vIOWNleS+i+aooeW8j+WvvOWHulxubGV0IGNmb0luc3RhbmNlOiBDRk9BZ2VudCB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q0ZPQWdlbnQoKTogQ0ZPQWdlbnQge1xuICBpZiAoIWNmb0luc3RhbmNlKSB7XG4gICAgY2ZvSW5zdGFuY2UgPSBuZXcgQ0ZPQWdlbnQoKTtcbiAgfVxuICByZXR1cm4gY2ZvSW5zdGFuY2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENGT0FnZW50O1xuIl0sIm5hbWVzIjpbIkJhc2VBZ2VudCIsImdldFRlY2huaWNhbEFuYWx5c3QiLCJhbmFseXplV2l0aENGTyIsImdldEZlZWRJdGVtcyIsImdldFBvcnRmb2xpb01hbmFnZXIiLCJDRk9BZ2VudCIsImFuYWx5emVTeW1ib2wiLCJzeW1ib2wiLCJ0YXNrIiwiaWQiLCJEYXRlIiwibm93IiwidHlwZSIsImRhdGEiLCJwcmlvcml0eSIsImNyZWF0ZWRBdCIsInJlc3VsdCIsInRlY2hBbmFseXN0IiwicHJvY2Vzc1Rhc2siLCJzdWNjZXNzIiwiRXJyb3IiLCJlcnJvciIsImNmb0FuYWx5c2lzIiwiY2FjaGVBbmFseXNpcyIsImFuYWx5emVNdWx0aXBsZSIsInN5bWJvbHMiLCJhbmFseXNlcyIsImFuYWx5c2lzIiwicHVzaCIsImNvbnNvbGUiLCJjcmVhdGVFcnJvckFuYWx5c2lzIiwibWVzc2FnZSIsImRlbGF5IiwiZXJyb3JNZXNzYWdlIiwidGltZXN0YW1wIiwicGVyc3BlY3RpdmVzIiwiYnVsbCIsIm1vZGUiLCJjb25maWRlbmNlIiwicmVhc29uaW5nIiwia2V5UG9pbnRzIiwicmlza0xldmVsIiwiYmVhciIsImluY2x1ZGVzIiwiY29uc2Vuc3VzIiwic2VudGltZW50Iiwic3VtbWFyeSIsImFjdGlvbiIsInRlY2huaWNhbERhdGEiLCJpbmRpY2F0b3JzIiwicnNpIiwibWE3IiwibWExNCIsInZvbGF0aWxpdHkiLCJ0cmVuZCIsInNpZ25hbHMiLCJnZXRNYXJrZXRPdmVydmlldyIsImJ1bGxpc2hDb3VudCIsImJlYXJpc2hDb3VudCIsIm5ldXRyYWxDb3VudCIsImVycm9yQ291bnQiLCJvcHBvcnR1bml0aWVzIiwicmlza3MiLCJ2YWxpZEFuYWx5c2VzIiwibGVuZ3RoIiwib3ZlcmFsbFNlbnRpbWVudCIsInRvcE9wcG9ydHVuaXRpZXMiLCJzbGljZSIsInRvcFJpc2tzIiwiZ2VuZXJhdGVJbnNpZ2h0cyIsImluc2lnaHRzIiwidGl0bGUiLCJjb250ZW50IiwicmVsYXRlZFN5bWJvbHMiLCJidWxsQ29uZiIsImJlYXJDb25mIiwiTWF0aCIsImFicyIsInRvRml4ZWQiLCJzb3J0IiwiYSIsImIiLCJhbmFseXplRnJvbUZlZWQiLCJ0YXJnZXRTeW1ib2xzIiwicmVjb21tZW5kYXRpb25zIiwicmVjZW50RmVlZHMiLCJsaW1pdCIsInRoaXJ0eU1pbnV0ZXNBZ28iLCJyZWxldmFudEZlZWRzIiwiZmlsdGVyIiwiZiIsImdldFRpbWUiLCJzeW1ib2xGZWVkcyIsInRlY2hTaWduYWxzIiwicGFBbmFseXNlcyIsInNlbnRpbWVudEZlZWRzIiwiYnVsbGlzaFNjb3JlIiwiYmVhcmlzaFNjb3JlIiwidG90YWxXZWlnaHQiLCJmb3JFYWNoIiwiZmVlZCIsInNpZ25hbFR5cGUiLCJzaWduYWxDb25maWRlbmNlIiwiYnVsbENvbmZpZGVuY2UiLCJiZWFyQ29uZmlkZW5jZSIsImNvbnNlbnN1c1NlbnRpbWVudCIsInBvc2l0aW9uU2l6ZSIsInBlcmNlbnRhZ2UiLCJyb3VuZCIsImN1cnJlbnRQcmljZSIsImdldEN1cnJlbnRQcmljZSIsInN0b3BMb3NzIiwidW5kZWZpbmVkIiwidGFrZVByb2ZpdCIsInBvc2l0aW9uIiwic2l6ZSIsInRpbWVmcmFtZSIsIm1vY2tQcmljZXMiLCJCVEMiLCJET0dFIiwiRVRIIiwiU09MIiwiZXhlY3V0ZVRyYWRlIiwicGFyYW1zIiwicG9ydGZvbGlvIiwic2lkZSIsImFtb3VudCIsInF1YW50aXR5IiwicHJpY2UiLCJ0b1VwcGVyQ2FzZSIsIm5vdGVzIiwicmVhc29uIiwiY3VycmVudCIsImdldFBvcnRmb2xpbyIsInRyYWRlIiwidG90YWwiLCJmZWUiLCJ0b3RhbEVxdWl0eSIsImJhbGFuY2UiLCJwb3NpdGlvbnMiLCJtYXAiLCJwIiwiYXZnUHJpY2UiLCJhbmFseXplQW5kVHJhZGUiLCJhdXRvRXhlY3V0ZSIsImV4ZWN1dGlvbnMiLCJyZWMiLCJlcXVpdHkiLCJmb3JtYXRUcmFkZVJlY29tbWVuZGF0aW9uIiwiYWN0aW9uRW1vamkiLCJzaXplVGV4dCIsInJlc3BvbnNlIiwiZm9ybWF0QW5hbHlzaXNGb3JDaGF0IiwidG9Mb2NhbGVTdHJpbmciLCJwb2ludCIsImVtb2ppIiwiYWN0aW9uVGV4dCIsImZvcm1hdE1hcmtldE92ZXJ2aWV3Iiwib3ZlcnZpZXciLCJzZW50aW1lbnRUZXh0Iiwiam9pbiIsInJlY2VudEFuYWx5c2VzIiwic2V0IiwibWF4Q2FjaGVTaXplIiwiZmlyc3RLZXkiLCJrZXlzIiwibmV4dCIsInZhbHVlIiwiZGVsZXRlIiwiZ2V0Q2FjaGVkQW5hbHlzaXMiLCJnZXQiLCJnZXRBbGxDYWNoZWRBbmFseXNlcyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImV4ZWN1dGVUYXNrIiwiZ2VuZXJhdGVSZXNwb25zZSIsImNvbnRleHQiLCJsb3dlck1zZyIsInRvTG93ZXJDYXNlIiwic3ltYm9sTWF0Y2giLCJtYXRjaCIsImNhY2hlZCIsImVycm9yTXNnIiwiY29uc3RydWN0b3IiLCJuYW1lIiwicm9sZSIsInN5c3RlbVByb21wdCIsIk1hcCIsIlhSUCIsIkFEQSIsImNmb0luc3RhbmNlIiwiZ2V0Q0ZPQWdlbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/agents/cfo.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/agents/tech-analyst.ts":
/*!************************************!*\
  !*** ./lib/agents/tech-analyst.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TechnicalAnalyst: function() { return /* binding */ TechnicalAnalyst; },\n/* harmony export */   getTechnicalAnalyst: function() { return /* binding */ getTechnicalAnalyst; }\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"(app-pages-browser)/./lib/agents/base.ts\");\n/* harmony import */ var _lib_data_coingecko__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/data/coingecko */ \"(app-pages-browser)/./lib/data/coingecko.ts\");\n/**\n * Technical Analyst Agent\n * 技术分析员 - 计算和分析技术指标\n */ \n\nclass TechnicalAnalyst extends _base__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    // ==================== 核心分析方法 ====================\n    /**\n   * 计算 RSI (Relative Strength Index)\n   * 使用 14 周期标准计算\n   */ calculateRSI(prices) {\n        let period = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 14;\n        if (prices.length < period + 1) {\n            throw new Error(\"RSI 计算需要至少 \".concat(period + 1, \" 个价格点\"));\n        }\n        let gains = 0;\n        let losses = 0;\n        // 计算初始平均涨跌\n        for(let i = 1; i <= period; i++){\n            const change = prices[i] - prices[i - 1];\n            if (change > 0) gains += change;\n            else losses += Math.abs(change);\n        }\n        let avgGain = gains / period;\n        let avgLoss = losses / period;\n        // 使用平滑 RSI 计算\n        for(let i = period + 1; i < prices.length; i++){\n            const change = prices[i] - prices[i - 1];\n            const gain = change > 0 ? change : 0;\n            const loss = change < 0 ? Math.abs(change) : 0;\n            avgGain = (avgGain * (period - 1) + gain) / period;\n            avgLoss = (avgLoss * (period - 1) + loss) / period;\n        }\n        if (avgLoss === 0) return 100;\n        const rs = avgGain / avgLoss;\n        const rsi = 100 - 100 / (1 + rs);\n        return Math.round(rsi * 100) / 100;\n    }\n    /**\n   * 计算简单移动平均线 (SMA)\n   */ calculateSMA(prices, period) {\n        if (prices.length < period) {\n            throw new Error(\"SMA 计算需要至少 \".concat(period, \" 个价格点\"));\n        }\n        const slice = prices.slice(-period);\n        const sum = slice.reduce((acc, price)=>acc + price, 0);\n        return Math.round(sum / period * 100) / 100;\n    }\n    /**\n   * 计算指数移动平均线 (EMA)\n   */ calculateEMA(prices, period) {\n        if (prices.length < period) {\n            throw new Error(\"EMA 计算需要至少 \".concat(period, \" 个价格点\"));\n        }\n        const multiplier = 2 / (period + 1);\n        let ema = prices.slice(0, period).reduce((a, b)=>a + b, 0) / period;\n        for(let i = period; i < prices.length; i++){\n            ema = (prices[i] - ema) * multiplier + ema;\n        }\n        return Math.round(ema * 100) / 100;\n    }\n    /**\n   * 计算波动率（价格标准差）\n   */ calculateVolatility(prices) {\n        let period = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 14;\n        if (prices.length < period) return 0;\n        const slice = prices.slice(-period);\n        const mean = slice.reduce((a, b)=>a + b, 0) / period;\n        const squaredDiffs = slice.map((price)=>Math.pow(price - mean, 2));\n        const variance = squaredDiffs.reduce((a, b)=>a + b, 0) / period;\n        const stdDev = Math.sqrt(variance);\n        // 返回相对波动率（标准差/均值 * 100）\n        return Math.round(stdDev / mean * 100 * 100) / 100;\n    }\n    /**\n   * 识别趋势\n   */ identifyTrend(prices) {\n        if (prices.length < 14) return \"sideways\";\n        const ma7 = this.calculateSMA(prices, 7);\n        const ma14 = this.calculateSMA(prices, 14);\n        const currentPrice = prices[prices.length - 1];\n        // 价格相对于均线的位置\n        const aboveMa7 = currentPrice > ma7;\n        const aboveMa14 = currentPrice > ma14;\n        const goldenCross = ma7 > ma14;\n        if (aboveMa7 && aboveMa14 && goldenCross) return \"up\";\n        if (!aboveMa7 && !aboveMa14 && !goldenCross) return \"down\";\n        return \"sideways\";\n    }\n    /**\n   * 计算支撑位和阻力位（简单实现）\n   */ calculateSupportResistance(prices) {\n        const window = 10;\n        const recentPrices = prices.slice(-window * 3);\n        let support = Math.min(...recentPrices);\n        let resistance = Math.max(...recentPrices);\n        // 稍微调整使其更合理\n        support = Math.round(support * 0.995 * 100) / 100;\n        resistance = Math.round(resistance * 1.005 * 100) / 100;\n        return {\n            support,\n            resistance\n        };\n    }\n    // ==================== 信号生成 ====================\n    /**\n   * 基于技术指标生成交易信号\n   */ generateSignals(symbol, indicators, prices) {\n        const signals = [];\n        // RSI 信号\n        if (indicators.rsi > 70) {\n            signals.push({\n                type: \"sell\",\n                indicator: \"RSI\",\n                confidence: Math.min((indicators.rsi - 70) / 30, 1),\n                description: \"\".concat(symbol, \" RSI 超买 (\").concat(indicators.rsi, \")\")\n            });\n        } else if (indicators.rsi < 30) {\n            signals.push({\n                type: \"buy\",\n                indicator: \"RSI\",\n                confidence: Math.min((30 - indicators.rsi) / 30, 1),\n                description: \"\".concat(symbol, \" RSI 超卖 (\").concat(indicators.rsi, \")\")\n            });\n        }\n        // 移动平均线信号\n        const currentPrice = prices[prices.length - 1];\n        if (currentPrice > indicators.ma7 && indicators.ma7 > indicators.ma14) {\n            signals.push({\n                type: \"buy\",\n                indicator: \"MA 趋势\",\n                confidence: 0.7,\n                description: \"\".concat(symbol, \" 价格在 MA7 之上，MA7 在 MA14 之上 - 看涨趋势\")\n            });\n        } else if (currentPrice < indicators.ma7 && indicators.ma7 < indicators.ma14) {\n            signals.push({\n                type: \"sell\",\n                indicator: \"MA 趋势\",\n                confidence: 0.7,\n                description: \"\".concat(symbol, \" 价格在 MA7 之下，MA7 在 MA14 之下 - 看跌趋势\")\n            });\n        }\n        // 趋势信号\n        if (indicators.trend === \"up\") {\n            signals.push({\n                type: \"buy\",\n                indicator: \"趋势\",\n                confidence: 0.6,\n                description: \"\".concat(symbol, \" 处于上涨趋势\")\n            });\n        } else if (indicators.trend === \"down\") {\n            signals.push({\n                type: \"sell\",\n                indicator: \"趋势\",\n                confidence: 0.6,\n                description: \"\".concat(symbol, \" 处于下跌趋势\")\n            });\n        }\n        // 如果没有明确信号，返回中性\n        if (signals.length === 0) {\n            signals.push({\n                type: \"neutral\",\n                indicator: \"综合\",\n                confidence: 0.5,\n                description: \"\".concat(symbol, \" 信号混杂，方向不明\")\n            });\n        }\n        return signals;\n    }\n    /**\n   * 计算综合评分\n   */ calculateCompositeScore(indicators) {\n        let score = 50; // 基准分\n        // RSI 贡献 (-20 to +20)\n        score += (50 - indicators.rsi) * 0.4;\n        // 趋势贡献\n        if (indicators.trend === \"up\") score += 15;\n        if (indicators.trend === \"down\") score -= 15;\n        // 波动率调整（高波动降低信心）\n        score -= indicators.volatility * 0.2;\n        return Math.max(0, Math.min(100, Math.round(score)));\n    }\n    // ==================== 公共方法 ====================\n    /**\n   * 分析单个币种\n   */ async analyzeSymbol(symbol, coinId) {\n        let days = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"14\";\n        const id = coinId || this.coinIdMap[symbol.toUpperCase()];\n        if (!id) {\n            throw new Error(\"未知币种: \".concat(symbol));\n        }\n        // 获取市场图表数据\n        const chartData = await (0,_lib_data_coingecko__WEBPACK_IMPORTED_MODULE_1__.getCoinMarketChart)(id, days);\n        const prices = chartData.prices.map((p)=>p[1]);\n        if (prices.length < 14) {\n            throw new Error(\"\".concat(symbol, \" 数据点不足\"));\n        }\n        // 计算指标\n        const rsi = this.calculateRSI(prices);\n        const ma7 = this.calculateSMA(prices, 7);\n        const ma14 = this.calculateSMA(prices, 14);\n        const ma30 = prices.length >= 30 ? this.calculateSMA(prices, 30) : undefined;\n        const volatility = this.calculateVolatility(prices);\n        const trend = this.identifyTrend(prices);\n        const { support, resistance } = this.calculateSupportResistance(prices);\n        const indicators = {\n            rsi,\n            ma7,\n            ma14,\n            ma30,\n            volatility,\n            trend,\n            support,\n            resistance\n        };\n        const signals = this.generateSignals(symbol, indicators, prices);\n        return {\n            symbol: symbol.toUpperCase(),\n            indicators,\n            signals,\n            timestamp: new Date()\n        };\n    }\n    /**\n   * 分析多个币种（用于定时任务）\n   */ async analyzeMultiple(symbols) {\n        const analyses = [];\n        const prices = [];\n        for (const symbol of symbols){\n            try {\n                const analysis = await this.analyzeSymbol(symbol);\n                analyses.push(analysis);\n                // 记录当前价格\n                prices.push({\n                    symbol: analysis.symbol,\n                    price: analysis.indicators.ma7\n                });\n            } catch (error) {\n                console.error(\"[TechAnalyst] Failed to analyze \".concat(symbol, \":\"), error);\n            }\n            // 添加小延迟避免请求过快\n            await this.delay(500);\n        }\n        return {\n            analyses,\n            prices,\n            timestamp: new Date()\n        };\n    }\n    /**\n   * 快速分析 BTC 和 DOGE（每5分钟调用）\n   */ async analyzeBTCAndDOGE() {\n        return this.analyzeMultiple([\n            \"BTC\",\n            \"DOGE\"\n        ]);\n    }\n    /**\n   * 生成技术指标摘要\n   */ generateSummary(analysis) {\n        const { symbol, indicators, signals } = analysis;\n        const compositeScore = this.calculateCompositeScore(indicators);\n        const bullishSignals = signals.filter((s)=>s.type === \"buy\" || s.type === \"strong_buy\");\n        const bearishSignals = signals.filter((s)=>s.type === \"sell\" || s.type === \"strong_sell\");\n        const trendText = indicators.trend === \"up\" ? \"上涨\" : indicators.trend === \"down\" ? \"下跌\" : \"横盘\";\n        let summary = \"[\".concat(symbol, \"] 技术评分: \").concat(compositeScore, \"/100\\n\");\n        summary += \"RSI: \".concat(indicators.rsi, \" | MA7: $\").concat(indicators.ma7, \" | MA14: $\").concat(indicators.ma14, \"\\n\");\n        summary += \"趋势: \".concat(trendText, \" | 波动率: \").concat(indicators.volatility, \"%\\n\");\n        summary += \"信号: \".concat(bullishSignals.length, \" 个看涨, \").concat(bearishSignals.length, \" 个看跌\\n\");\n        if (signals.length > 0) {\n            summary += \"主要信号: \".concat(signals[0].description);\n        }\n        return summary;\n    }\n    // ==================== 实现抽象方法 ====================\n    async executeTask(task) {\n        switch(task.type){\n            case \"analyze_symbol\":\n                {\n                    const { symbol, coinId, days } = task.data;\n                    const result = await this.analyzeSymbol(symbol, coinId, days);\n                    return result;\n                }\n            case \"analyze_multiple\":\n                {\n                    const { symbols } = task.data;\n                    const result = await this.analyzeMultiple(symbols);\n                    return result;\n                }\n            case \"analyze_btc_doge\":\n                {\n                    const result = await this.analyzeBTCAndDOGE();\n                    return result;\n                }\n            default:\n                throw new Error(\"未知的任务类型: \".concat(task.type));\n        }\n    }\n    async generateResponse(message, context) {\n        // 技术分析员主要是数据分析，对话功能简单实现\n        if (message.toLowerCase().includes(\"analyze\") || message.toLowerCase().includes(\"分析\")) {\n            var _message_match;\n            const symbol = ((_message_match = message.match(/\\b(BTC|DOGE|ETH|SOL|XRP|ADA)\\b/i)) === null || _message_match === void 0 ? void 0 : _message_match[0]) || \"BTC\";\n            try {\n                const analysis = await this.analyzeSymbol(symbol);\n                return this.generateSummary(analysis);\n            } catch (error) {\n                const errorMsg = error instanceof Error ? error.message : \"\";\n                if (errorMsg.includes(\"429\")) {\n                    return \"⏳ API 请求过于频繁，请等待 1-2 分钟后再试。\";\n                }\n                return \"抱歉，暂时无法分析 \".concat(symbol, \"。请稍后再试。\");\n            }\n        }\n        return \"我是技术分析员，可以帮你分析加密货币的技术指标。让我分析 BTC、DOGE 或其他支持的币种。\";\n    }\n    constructor(){\n        super({\n            name: \"TechAnalyst\",\n            role: \"tech-analyst\",\n            systemPrompt: \"你是加密货币市场的技术分析专家。\\n\\n你的职责：\\n1. 计算和分析技术指标（RSI、MA、波动率）\\n2. 识别趋势、支撑位和阻力位\\n3. 基于技术分析生成买入/卖出/中性信号\\n4. 提供清晰、数据驱动的洞察\\n\\n始终保持数字精确，并清楚解释你的推理过程。\"\n        });\n        this.coinIdMap = {\n            BTC: \"bitcoin\",\n            DOGE: \"dogecoin\",\n            ETH: \"ethereum\",\n            SOL: \"solana\",\n            XRP: \"ripple\",\n            ADA: \"cardano\",\n            AVAX: \"avalanche-2\",\n            DOT: \"polkadot\"\n        };\n    }\n}\n// 单例模式导出\nlet techAnalystInstance = null;\nfunction getTechnicalAnalyst() {\n    if (!techAnalystInstance) {\n        techAnalystInstance = new TechnicalAnalyst();\n    }\n    return techAnalystInstance;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (TechnicalAnalyst);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hZ2VudHMvdGVjaC1hbmFseXN0LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FFOEI7QUFDb0U7QUFxQjVGLE1BQU1FLHlCQUF5QkYsNkNBQVNBO0lBNEI3QyxtREFBbUQ7SUFFbkQ7OztHQUdDLEdBQ0QsYUFBcUJJLE1BQWdCLEVBQStCO1lBQTdCQyxTQUFBQSxpRUFBaUI7UUFDdEQsSUFBSUQsT0FBT0UsTUFBTSxHQUFHRCxTQUFTLEdBQUc7WUFDOUIsTUFBTSxJQUFJRSxNQUFNLGNBQXlCLE9BQVhGLFNBQVMsR0FBRTtRQUMzQztRQUVBLElBQUlHLFFBQVE7UUFDWixJQUFJQyxTQUFTO1FBRWIsV0FBVztRQUNYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxLQUFLTCxRQUFRSyxJQUFLO1lBQ2hDLE1BQU1DLFNBQVNQLE1BQU0sQ0FBQ00sRUFBRSxHQUFHTixNQUFNLENBQUNNLElBQUksRUFBRTtZQUN4QyxJQUFJQyxTQUFTLEdBQUdILFNBQVNHO2lCQUNwQkYsVUFBVUcsS0FBS0MsR0FBRyxDQUFDRjtRQUMxQjtRQUVBLElBQUlHLFVBQVVOLFFBQVFIO1FBQ3RCLElBQUlVLFVBQVVOLFNBQVNKO1FBRXZCLGNBQWM7UUFDZCxJQUFLLElBQUlLLElBQUlMLFNBQVMsR0FBR0ssSUFBSU4sT0FBT0UsTUFBTSxFQUFFSSxJQUFLO1lBQy9DLE1BQU1DLFNBQVNQLE1BQU0sQ0FBQ00sRUFBRSxHQUFHTixNQUFNLENBQUNNLElBQUksRUFBRTtZQUN4QyxNQUFNTSxPQUFPTCxTQUFTLElBQUlBLFNBQVM7WUFDbkMsTUFBTU0sT0FBT04sU0FBUyxJQUFJQyxLQUFLQyxHQUFHLENBQUNGLFVBQVU7WUFFN0NHLFVBQVUsQ0FBQ0EsVUFBV1QsQ0FBQUEsU0FBUyxLQUFLVyxJQUFHLElBQUtYO1lBQzVDVSxVQUFVLENBQUNBLFVBQVdWLENBQUFBLFNBQVMsS0FBS1ksSUFBRyxJQUFLWjtRQUM5QztRQUVBLElBQUlVLFlBQVksR0FBRyxPQUFPO1FBRTFCLE1BQU1HLEtBQUtKLFVBQVVDO1FBQ3JCLE1BQU1JLE1BQU0sTUFBTSxNQUFPLEtBQUlELEVBQUM7UUFFOUIsT0FBT04sS0FBS1EsS0FBSyxDQUFDRCxNQUFNLE9BQU87SUFDakM7SUFFQTs7R0FFQyxHQUNELGFBQXFCZixNQUFnQixFQUFFQyxNQUFjLEVBQVU7UUFDN0QsSUFBSUQsT0FBT0UsTUFBTSxHQUFHRCxRQUFRO1lBQzFCLE1BQU0sSUFBSUUsTUFBTSxjQUFxQixPQUFQRixRQUFPO1FBQ3ZDO1FBRUEsTUFBTWlCLFFBQVFsQixPQUFPa0IsS0FBSyxDQUFDLENBQUNqQjtRQUM1QixNQUFNa0IsTUFBTUQsTUFBTUUsTUFBTSxDQUFDLENBQUNDLEtBQUtDLFFBQVVELE1BQU1DLE9BQU87UUFDdEQsT0FBT2QsS0FBS1EsS0FBSyxDQUFDLE1BQU9mLFNBQVUsT0FBTztJQUM1QztJQUVBOztHQUVDLEdBQ0QsYUFBcUJELE1BQWdCLEVBQUVDLE1BQWMsRUFBVTtRQUM3RCxJQUFJRCxPQUFPRSxNQUFNLEdBQUdELFFBQVE7WUFDMUIsTUFBTSxJQUFJRSxNQUFNLGNBQXFCLE9BQVBGLFFBQU87UUFDdkM7UUFFQSxNQUFNdUIsYUFBYSxJQUFLdkIsQ0FBQUEsU0FBUztRQUNqQyxJQUFJd0IsTUFBTXpCLE9BQU9rQixLQUFLLENBQUMsR0FBR2pCLFFBQVFtQixNQUFNLENBQUMsQ0FBQ00sR0FBR0MsSUFBTUQsSUFBSUMsR0FBRyxLQUFLMUI7UUFFL0QsSUFBSyxJQUFJSyxJQUFJTCxRQUFRSyxJQUFJTixPQUFPRSxNQUFNLEVBQUVJLElBQUs7WUFDM0NtQixNQUFNLENBQUN6QixNQUFNLENBQUNNLEVBQUUsR0FBR21CLEdBQUUsSUFBS0QsYUFBYUM7UUFDekM7UUFFQSxPQUFPakIsS0FBS1EsS0FBSyxDQUFDUyxNQUFNLE9BQU87SUFDakM7SUFFQTs7R0FFQyxHQUNELG9CQUE0QnpCLE1BQWdCLEVBQStCO1lBQTdCQyxTQUFBQSxpRUFBaUI7UUFDN0QsSUFBSUQsT0FBT0UsTUFBTSxHQUFHRCxRQUFRLE9BQU87UUFFbkMsTUFBTWlCLFFBQVFsQixPQUFPa0IsS0FBSyxDQUFDLENBQUNqQjtRQUM1QixNQUFNNEIsT0FBT1gsTUFBTUUsTUFBTSxDQUFDLENBQUNNLEdBQUdDLElBQU1ELElBQUlDLEdBQUcsS0FBSzFCO1FBQ2hELE1BQU02QixlQUFlWixNQUFNYSxHQUFHLENBQUNULENBQUFBLFFBQVNkLEtBQUt3QixHQUFHLENBQUNWLFFBQVFPLE1BQU07UUFDL0QsTUFBTUksV0FBV0gsYUFBYVYsTUFBTSxDQUFDLENBQUNNLEdBQUdDLElBQU1ELElBQUlDLEdBQUcsS0FBSzFCO1FBQzNELE1BQU1pQyxTQUFTMUIsS0FBSzJCLElBQUksQ0FBQ0Y7UUFFekIsd0JBQXdCO1FBQ3hCLE9BQU96QixLQUFLUSxLQUFLLENBQUMsU0FBVWEsT0FBUSxNQUFNLE9BQU87SUFDbkQ7SUFFQTs7R0FFQyxHQUNELGNBQXNCN0IsTUFBZ0IsRUFBOEI7UUFDbEUsSUFBSUEsT0FBT0UsTUFBTSxHQUFHLElBQUksT0FBTztRQUUvQixNQUFNbUMsTUFBTSxJQUFJLENBQUNwQixZQUFZLENBQUNqQixRQUFRO1FBQ3RDLE1BQU1zQyxPQUFPLElBQUksQ0FBQ3JCLFlBQVksQ0FBQ2pCLFFBQVE7UUFDdkMsTUFBTXVDLGVBQWV2QyxNQUFNLENBQUNBLE9BQU9FLE1BQU0sR0FBRyxFQUFFO1FBRTlDLGFBQWE7UUFDYixNQUFNc0MsV0FBV0QsZUFBZUY7UUFDaEMsTUFBTUksWUFBWUYsZUFBZUQ7UUFDakMsTUFBTUksY0FBY0wsTUFBTUM7UUFFMUIsSUFBSUUsWUFBWUMsYUFBYUMsYUFBYSxPQUFPO1FBQ2pELElBQUksQ0FBQ0YsWUFBWSxDQUFDQyxhQUFhLENBQUNDLGFBQWEsT0FBTztRQUNwRCxPQUFPO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELDJCQUNFMUMsTUFBZ0IsRUFDeUI7UUFDekMsTUFBTTRDLFNBQVM7UUFDZixNQUFNQyxlQUFlN0MsT0FBT2tCLEtBQUssQ0FBQyxDQUFDMEIsU0FBUztRQUU1QyxJQUFJRSxVQUFVdEMsS0FBS3VDLEdBQUcsSUFBSUY7UUFDMUIsSUFBSUcsYUFBYXhDLEtBQUt5QyxHQUFHLElBQUlKO1FBRTdCLFlBQVk7UUFDWkMsVUFBVXRDLEtBQUtRLEtBQUssQ0FBQzhCLFVBQVUsUUFBUSxPQUFPO1FBQzlDRSxhQUFheEMsS0FBS1EsS0FBSyxDQUFDZ0MsYUFBYSxRQUFRLE9BQU87UUFFcEQsT0FBTztZQUFFRjtZQUFTRTtRQUFXO0lBQy9CO0lBRUEsaURBQWlEO0lBRWpEOztHQUVDLEdBQ0QsZ0JBQ0VHLE1BQWMsRUFDZEMsVUFBK0IsRUFDL0JwRCxNQUFnQixFQUNHO1FBQ25CLE1BQU1xRCxVQUE2QixFQUFFO1FBRXJDLFNBQVM7UUFDVCxJQUFJRCxXQUFXckMsR0FBRyxHQUFHLElBQUk7WUFDdkJzQyxRQUFRQyxJQUFJLENBQUM7Z0JBQ1hDLE1BQU07Z0JBQ05DLFdBQVc7Z0JBQ1hDLFlBQVlqRCxLQUFLdUMsR0FBRyxDQUFDLENBQUNLLFdBQVdyQyxHQUFHLEdBQUcsRUFBQyxJQUFLLElBQUk7Z0JBQ2pEMkMsYUFBYSxHQUFxQk4sT0FBbEJELFFBQU8sYUFBMEIsT0FBZkMsV0FBV3JDLEdBQUcsRUFBQztZQUNuRDtRQUNGLE9BQU8sSUFBSXFDLFdBQVdyQyxHQUFHLEdBQUcsSUFBSTtZQUM5QnNDLFFBQVFDLElBQUksQ0FBQztnQkFDWEMsTUFBTTtnQkFDTkMsV0FBVztnQkFDWEMsWUFBWWpELEtBQUt1QyxHQUFHLENBQUMsQ0FBQyxLQUFLSyxXQUFXckMsR0FBRyxJQUFJLElBQUk7Z0JBQ2pEMkMsYUFBYSxHQUFxQk4sT0FBbEJELFFBQU8sYUFBMEIsT0FBZkMsV0FBV3JDLEdBQUcsRUFBQztZQUNuRDtRQUNGO1FBRUEsVUFBVTtRQUNWLE1BQU13QixlQUFldkMsTUFBTSxDQUFDQSxPQUFPRSxNQUFNLEdBQUcsRUFBRTtRQUM5QyxJQUFJcUMsZUFBZWEsV0FBV2YsR0FBRyxJQUFJZSxXQUFXZixHQUFHLEdBQUdlLFdBQVdkLElBQUksRUFBRTtZQUNyRWUsUUFBUUMsSUFBSSxDQUFDO2dCQUNYQyxNQUFNO2dCQUNOQyxXQUFXO2dCQUNYQyxZQUFZO2dCQUNaQyxhQUFhLEdBQVUsT0FBUFAsUUFBTztZQUN6QjtRQUNGLE9BQU8sSUFBSVosZUFBZWEsV0FBV2YsR0FBRyxJQUFJZSxXQUFXZixHQUFHLEdBQUdlLFdBQVdkLElBQUksRUFBRTtZQUM1RWUsUUFBUUMsSUFBSSxDQUFDO2dCQUNYQyxNQUFNO2dCQUNOQyxXQUFXO2dCQUNYQyxZQUFZO2dCQUNaQyxhQUFhLEdBQVUsT0FBUFAsUUFBTztZQUN6QjtRQUNGO1FBRUEsT0FBTztRQUNQLElBQUlDLFdBQVdPLEtBQUssS0FBSyxNQUFNO1lBQzdCTixRQUFRQyxJQUFJLENBQUM7Z0JBQ1hDLE1BQU07Z0JBQ05DLFdBQVc7Z0JBQ1hDLFlBQVk7Z0JBQ1pDLGFBQWEsR0FBVSxPQUFQUCxRQUFPO1lBQ3pCO1FBQ0YsT0FBTyxJQUFJQyxXQUFXTyxLQUFLLEtBQUssUUFBUTtZQUN0Q04sUUFBUUMsSUFBSSxDQUFDO2dCQUNYQyxNQUFNO2dCQUNOQyxXQUFXO2dCQUNYQyxZQUFZO2dCQUNaQyxhQUFhLEdBQVUsT0FBUFAsUUFBTztZQUN6QjtRQUNGO1FBRUEsZ0JBQWdCO1FBQ2hCLElBQUlFLFFBQVFuRCxNQUFNLEtBQUssR0FBRztZQUN4Qm1ELFFBQVFDLElBQUksQ0FBQztnQkFDWEMsTUFBTTtnQkFDTkMsV0FBVztnQkFDWEMsWUFBWTtnQkFDWkMsYUFBYSxHQUFVLE9BQVBQLFFBQU87WUFDekI7UUFDRjtRQUVBLE9BQU9FO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELHdCQUFnQ0QsVUFBK0IsRUFBVTtRQUN2RSxJQUFJUyxRQUFRLElBQUksTUFBTTtRQUV0QixzQkFBc0I7UUFDdEJBLFNBQVMsQ0FBQyxLQUFLVCxXQUFXckMsR0FBRyxJQUFJO1FBRWpDLE9BQU87UUFDUCxJQUFJcUMsV0FBV08sS0FBSyxLQUFLLE1BQU1FLFNBQVM7UUFDeEMsSUFBSVQsV0FBV08sS0FBSyxLQUFLLFFBQVFFLFNBQVM7UUFFMUMsaUJBQWlCO1FBQ2pCQSxTQUFTVCxXQUFXVSxVQUFVLEdBQUc7UUFFakMsT0FBT3RELEtBQUt5QyxHQUFHLENBQUMsR0FBR3pDLEtBQUt1QyxHQUFHLENBQUMsS0FBS3ZDLEtBQUtRLEtBQUssQ0FBQzZDO0lBQzlDO0lBRUEsaURBQWlEO0lBRWpEOztHQUVDLEdBQ0QsTUFBTUUsY0FBY1osTUFBYyxFQUFFYSxNQUFlLEVBQW1EO1lBQWpEQyxPQUFBQSxpRUFBZTtRQUNsRSxNQUFNQyxLQUFLRixVQUFVLElBQUksQ0FBQ0csU0FBUyxDQUFDaEIsT0FBT2lCLFdBQVcsR0FBRztRQUN6RCxJQUFJLENBQUNGLElBQUk7WUFDUCxNQUFNLElBQUkvRCxNQUFNLFNBQWdCLE9BQVBnRDtRQUMzQjtRQUVBLFdBQVc7UUFDWCxNQUFNa0IsWUFBWSxNQUFNeEUsdUVBQWtCQSxDQUFDcUUsSUFBSUQ7UUFDL0MsTUFBTWpFLFNBQVNxRSxVQUFVckUsTUFBTSxDQUFDK0IsR0FBRyxDQUFDdUMsQ0FBQUEsSUFBS0EsQ0FBQyxDQUFDLEVBQUU7UUFFN0MsSUFBSXRFLE9BQU9FLE1BQU0sR0FBRyxJQUFJO1lBQ3RCLE1BQU0sSUFBSUMsTUFBTSxHQUFVLE9BQVBnRCxRQUFPO1FBQzVCO1FBRUEsT0FBTztRQUNQLE1BQU1wQyxNQUFNLElBQUksQ0FBQ2hCLFlBQVksQ0FBQ0M7UUFDOUIsTUFBTXFDLE1BQU0sSUFBSSxDQUFDcEIsWUFBWSxDQUFDakIsUUFBUTtRQUN0QyxNQUFNc0MsT0FBTyxJQUFJLENBQUNyQixZQUFZLENBQUNqQixRQUFRO1FBQ3ZDLE1BQU11RSxPQUFPdkUsT0FBT0UsTUFBTSxJQUFJLEtBQUssSUFBSSxDQUFDZSxZQUFZLENBQUNqQixRQUFRLE1BQU13RTtRQUNuRSxNQUFNVixhQUFhLElBQUksQ0FBQ2xDLG1CQUFtQixDQUFDNUI7UUFDNUMsTUFBTTJELFFBQVEsSUFBSSxDQUFDdkIsYUFBYSxDQUFDcEM7UUFDakMsTUFBTSxFQUFFOEMsT0FBTyxFQUFFRSxVQUFVLEVBQUUsR0FBRyxJQUFJLENBQUNMLDBCQUEwQixDQUFDM0M7UUFFaEUsTUFBTW9ELGFBQWtDO1lBQ3RDckM7WUFDQXNCO1lBQ0FDO1lBQ0FpQztZQUNBVDtZQUNBSDtZQUNBYjtZQUNBRTtRQUNGO1FBRUEsTUFBTUssVUFBVSxJQUFJLENBQUNILGVBQWUsQ0FBQ0MsUUFBUUMsWUFBWXBEO1FBRXpELE9BQU87WUFDTG1ELFFBQVFBLE9BQU9pQixXQUFXO1lBQzFCaEI7WUFDQUM7WUFDQW9CLFdBQVcsSUFBSUM7UUFDakI7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTUMsZ0JBQWdCQyxPQUFpQixFQUErQjtRQUNwRSxNQUFNQyxXQUFnQyxFQUFFO1FBQ3hDLE1BQU03RSxTQUFtRCxFQUFFO1FBRTNELEtBQUssTUFBTW1ELFVBQVV5QixRQUFTO1lBQzVCLElBQUk7Z0JBQ0YsTUFBTUUsV0FBVyxNQUFNLElBQUksQ0FBQ2YsYUFBYSxDQUFDWjtnQkFDMUMwQixTQUFTdkIsSUFBSSxDQUFDd0I7Z0JBQ2QsU0FBUztnQkFDVDlFLE9BQU9zRCxJQUFJLENBQUM7b0JBQ1ZILFFBQVEyQixTQUFTM0IsTUFBTTtvQkFDdkI3QixPQUFPd0QsU0FBUzFCLFVBQVUsQ0FBQ2YsR0FBRztnQkFDaEM7WUFDRixFQUFFLE9BQU8wQyxPQUFPO2dCQUNkQyxRQUFRRCxLQUFLLENBQUMsbUNBQTBDLE9BQVA1QixRQUFPLE1BQUk0QjtZQUM5RDtZQUNBLGNBQWM7WUFDZCxNQUFNLElBQUksQ0FBQ0UsS0FBSyxDQUFDO1FBQ25CO1FBRUEsT0FBTztZQUNMSjtZQUNBN0U7WUFDQXlFLFdBQVcsSUFBSUM7UUFDakI7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTVEsb0JBQWlEO1FBQ3JELE9BQU8sSUFBSSxDQUFDUCxlQUFlLENBQUM7WUFBQztZQUFPO1NBQU87SUFDN0M7SUFFQTs7R0FFQyxHQUNEUSxnQkFBZ0JMLFFBQTJCLEVBQVU7UUFDbkQsTUFBTSxFQUFFM0IsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRSxHQUFHeUI7UUFDeEMsTUFBTU0saUJBQWlCLElBQUksQ0FBQ3hCLHVCQUF1QixDQUFDUjtRQUVwRCxNQUFNaUMsaUJBQWlCaEMsUUFBUWlDLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRWhDLElBQUksS0FBSyxTQUFTZ0MsRUFBRWhDLElBQUksS0FBSztRQUMxRSxNQUFNaUMsaUJBQWlCbkMsUUFBUWlDLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRWhDLElBQUksS0FBSyxVQUFVZ0MsRUFBRWhDLElBQUksS0FBSztRQUUzRSxNQUFNa0MsWUFBWXJDLFdBQVdPLEtBQUssS0FBSyxPQUFPLE9BQU9QLFdBQVdPLEtBQUssS0FBSyxTQUFTLE9BQU87UUFFMUYsSUFBSStCLFVBQVUsSUFBcUJOLE9BQWpCakMsUUFBTyxZQUF5QixPQUFmaUMsZ0JBQWU7UUFDbERNLFdBQVcsUUFBa0N0QyxPQUExQkEsV0FBV3JDLEdBQUcsRUFBQyxhQUFzQ3FDLE9BQTNCQSxXQUFXZixHQUFHLEVBQUMsY0FBNEIsT0FBaEJlLFdBQVdkLElBQUksRUFBQztRQUN4Rm9ELFdBQVcsT0FBMkJ0QyxPQUFwQnFDLFdBQVUsWUFBZ0MsT0FBdEJyQyxXQUFXVSxVQUFVLEVBQUM7UUFDNUQ0QixXQUFXLE9BQXFDRixPQUE5QkgsZUFBZW5GLE1BQU0sRUFBQyxVQUE4QixPQUF0QnNGLGVBQWV0RixNQUFNLEVBQUM7UUFFdEUsSUFBSW1ELFFBQVFuRCxNQUFNLEdBQUcsR0FBRztZQUN0QndGLFdBQVcsU0FBZ0MsT0FBdkJyQyxPQUFPLENBQUMsRUFBRSxDQUFDSyxXQUFXO1FBQzVDO1FBRUEsT0FBT2dDO0lBQ1Q7SUFFQSxtREFBbUQ7SUFFbkQsTUFBTUMsWUFBZUMsSUFBZSxFQUFjO1FBQ2hELE9BQVFBLEtBQUtyQyxJQUFJO1lBQ2YsS0FBSztnQkFBa0I7b0JBQ3JCLE1BQU0sRUFBRUosTUFBTSxFQUFFYSxNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHMkIsS0FBS0MsSUFBSTtvQkFDMUMsTUFBTUMsU0FBUyxNQUFNLElBQUksQ0FBQy9CLGFBQWEsQ0FBQ1osUUFBUWEsUUFBUUM7b0JBQ3hELE9BQU82QjtnQkFDVDtZQUVBLEtBQUs7Z0JBQW9CO29CQUN2QixNQUFNLEVBQUVsQixPQUFPLEVBQUUsR0FBR2dCLEtBQUtDLElBQUk7b0JBQzdCLE1BQU1DLFNBQVMsTUFBTSxJQUFJLENBQUNuQixlQUFlLENBQUNDO29CQUMxQyxPQUFPa0I7Z0JBQ1Q7WUFFQSxLQUFLO2dCQUFvQjtvQkFDdkIsTUFBTUEsU0FBUyxNQUFNLElBQUksQ0FBQ1osaUJBQWlCO29CQUMzQyxPQUFPWTtnQkFDVDtZQUVBO2dCQUNFLE1BQU0sSUFBSTNGLE1BQU0sWUFBc0IsT0FBVnlGLEtBQUtyQyxJQUFJO1FBQ3pDO0lBQ0Y7SUFFQSxNQUFnQndDLGlCQUNkQyxPQUFlLEVBQ2ZDLE9BQWlDLEVBQ2hCO1FBQ2pCLHdCQUF3QjtRQUN4QixJQUFJRCxRQUFRRSxXQUFXLEdBQUdDLFFBQVEsQ0FBQyxjQUFjSCxRQUFRRSxXQUFXLEdBQUdDLFFBQVEsQ0FBQyxPQUFPO2dCQUN0RUg7WUFBZixNQUFNN0MsU0FBUzZDLEVBQUFBLGlCQUFBQSxRQUFRSSxLQUFLLENBQUMsZ0RBQWRKLHFDQUFBQSxjQUFrRCxDQUFDLEVBQUUsS0FBSTtZQUN4RSxJQUFJO2dCQUNGLE1BQU1sQixXQUFXLE1BQU0sSUFBSSxDQUFDZixhQUFhLENBQUNaO2dCQUMxQyxPQUFPLElBQUksQ0FBQ2dDLGVBQWUsQ0FBQ0w7WUFDOUIsRUFBRSxPQUFPQyxPQUFPO2dCQUNkLE1BQU1zQixXQUFXdEIsaUJBQWlCNUUsUUFBUTRFLE1BQU1pQixPQUFPLEdBQUc7Z0JBQzFELElBQUlLLFNBQVNGLFFBQVEsQ0FBQyxRQUFRO29CQUM1QixPQUFRO2dCQUNWO2dCQUNBLE9BQU8sYUFBb0IsT0FBUGhELFFBQU87WUFDN0I7UUFDRjtRQUVBLE9BQVE7SUFDVjtJQTVZQW1ELGFBQWM7UUFDWixLQUFLLENBQUM7WUFDSkMsTUFBTTtZQUNOQyxNQUFNO1lBQ05DLGNBQWU7UUFTakI7YUF4Qk10QyxZQUFvQztZQUMxQ3VDLEtBQUs7WUFDTEMsTUFBTTtZQUNOQyxLQUFLO1lBQ0xDLEtBQUs7WUFDTEMsS0FBSztZQUNMQyxLQUFLO1lBQ0xDLE1BQU07WUFDTkMsS0FBSztRQUNQO0lBZ0JBO0FBK1hGO0FBRUEsU0FBUztBQUNULElBQUlDLHNCQUErQztBQUU1QyxTQUFTQztJQUNkLElBQUksQ0FBQ0QscUJBQXFCO1FBQ3hCQSxzQkFBc0IsSUFBSXBIO0lBQzVCO0lBQ0EsT0FBT29IO0FBQ1Q7QUFFQSwrREFBZXBILGdCQUFnQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYWdlbnRzL3RlY2gtYW5hbHlzdC50cz8zNWQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVjaG5pY2FsIEFuYWx5c3QgQWdlbnRcbiAqIOaKgOacr+WIhuaekOWRmCAtIOiuoeeul+WSjOWIhuaekOaKgOacr+aMh+agh1xuICovXG5cbmltcG9ydCBCYXNlQWdlbnQgZnJvbSBcIi4vYmFzZVwiO1xuaW1wb3J0IHsgZ2V0QlRDQW5kRE9HRURhdGEsIGdldENvaW5NYXJrZXRDaGFydCwgdHlwZSBDb2luTWFya2V0Q2hhcnQgfSBmcm9tIFwiQC9saWIvZGF0YS9jb2luZ2Vja29cIjtcbmltcG9ydCB0eXBlIHtcbiAgQWdlbnRUYXNrLFxuICBUZWNobmljYWxJbmRpY2F0b3JzLFxuICBUZWNobmljYWxBbmFseXNpcyxcbiAgVGVjaG5pY2FsU2lnbmFsLFxuICBTaWduYWxUeXBlLFxufSBmcm9tIFwiQC9saWIvdHlwZXNcIjtcblxuaW50ZXJmYWNlIFRlY2hBbmFseXNpc1Rhc2sge1xuICBzeW1ib2w6IHN0cmluZztcbiAgY29pbklkPzogc3RyaW5nOyAvLyBDb2luR2Vja28gSURcbiAgZGF5cz86IHN0cmluZzsgLy8g5pWw5o2u5aSp5pWwXG59XG5cbmludGVyZmFjZSBNdWx0aUFzc2V0QW5hbHlzaXMge1xuICBhbmFseXNlczogVGVjaG5pY2FsQW5hbHlzaXNbXTtcbiAgcHJpY2VzOiBBcnJheTx7IHN5bWJvbDogc3RyaW5nOyBwcmljZTogbnVtYmVyIH0+O1xuICB0aW1lc3RhbXA6IERhdGU7XG59XG5cbmV4cG9ydCBjbGFzcyBUZWNobmljYWxBbmFseXN0IGV4dGVuZHMgQmFzZUFnZW50IHtcbiAgcHJpdmF0ZSBjb2luSWRNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgQlRDOiBcImJpdGNvaW5cIixcbiAgICBET0dFOiBcImRvZ2Vjb2luXCIsXG4gICAgRVRIOiBcImV0aGVyZXVtXCIsXG4gICAgU09MOiBcInNvbGFuYVwiLFxuICAgIFhSUDogXCJyaXBwbGVcIixcbiAgICBBREE6IFwiY2FyZGFub1wiLFxuICAgIEFWQVg6IFwiYXZhbGFuY2hlLTJcIixcbiAgICBET1Q6IFwicG9sa2Fkb3RcIixcbiAgfTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIlRlY2hBbmFseXN0XCIsXG4gICAgICByb2xlOiBcInRlY2gtYW5hbHlzdFwiLFxuICAgICAgc3lzdGVtUHJvbXB0OiBg5L2g5piv5Yqg5a+G6LSn5biB5biC5Zy655qE5oqA5pyv5YiG5p6Q5LiT5a6244CCXG5cbuS9oOeahOiBjOi0o++8mlxuMS4g6K6h566X5ZKM5YiG5p6Q5oqA5pyv5oyH5qCH77yIUlNJ44CBTUHjgIHms6LliqjnjofvvIlcbjIuIOivhuWIq+i2i+WKv+OAgeaUr+aSkeS9jeWSjOmYu+WKm+S9jVxuMy4g5Z+65LqO5oqA5pyv5YiG5p6Q55Sf5oiQ5Lmw5YWlL+WNluWHui/kuK3mgKfkv6Hlj7dcbjQuIOaPkOS+m+a4heaZsOOAgeaVsOaNrumpseWKqOeahOa0nuWvn1xuXG7lp4vnu4jkv53mjIHmlbDlrZfnsr7noa7vvIzlubbmuIXmpZrop6Pph4rkvaDnmoTmjqjnkIbov4fnqIvjgIJgLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0g5qC45b+D5YiG5p6Q5pa55rOVID09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIOiuoeeulyBSU0kgKFJlbGF0aXZlIFN0cmVuZ3RoIEluZGV4KVxuICAgKiDkvb/nlKggMTQg5ZGo5pyf5qCH5YeG6K6h566XXG4gICAqL1xuICBwcml2YXRlIGNhbGN1bGF0ZVJTSShwcmljZXM6IG51bWJlcltdLCBwZXJpb2Q6IG51bWJlciA9IDE0KTogbnVtYmVyIHtcbiAgICBpZiAocHJpY2VzLmxlbmd0aCA8IHBlcmlvZCArIDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUlNJIOiuoeeul+mcgOimgeiHs+WwkSAke3BlcmlvZCArIDF9IOS4quS7t+agvOeCuWApO1xuICAgIH1cblxuICAgIGxldCBnYWlucyA9IDA7XG4gICAgbGV0IGxvc3NlcyA9IDA7XG5cbiAgICAvLyDorqHnrpfliJ3lp4vlubPlnYfmtqjot4xcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBwZXJpb2Q7IGkrKykge1xuICAgICAgY29uc3QgY2hhbmdlID0gcHJpY2VzW2ldIC0gcHJpY2VzW2kgLSAxXTtcbiAgICAgIGlmIChjaGFuZ2UgPiAwKSBnYWlucyArPSBjaGFuZ2U7XG4gICAgICBlbHNlIGxvc3NlcyArPSBNYXRoLmFicyhjaGFuZ2UpO1xuICAgIH1cblxuICAgIGxldCBhdmdHYWluID0gZ2FpbnMgLyBwZXJpb2Q7XG4gICAgbGV0IGF2Z0xvc3MgPSBsb3NzZXMgLyBwZXJpb2Q7XG5cbiAgICAvLyDkvb/nlKjlubPmu5EgUlNJIOiuoeeul1xuICAgIGZvciAobGV0IGkgPSBwZXJpb2QgKyAxOyBpIDwgcHJpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFuZ2UgPSBwcmljZXNbaV0gLSBwcmljZXNbaSAtIDFdO1xuICAgICAgY29uc3QgZ2FpbiA9IGNoYW5nZSA+IDAgPyBjaGFuZ2UgOiAwO1xuICAgICAgY29uc3QgbG9zcyA9IGNoYW5nZSA8IDAgPyBNYXRoLmFicyhjaGFuZ2UpIDogMDtcblxuICAgICAgYXZnR2FpbiA9IChhdmdHYWluICogKHBlcmlvZCAtIDEpICsgZ2FpbikgLyBwZXJpb2Q7XG4gICAgICBhdmdMb3NzID0gKGF2Z0xvc3MgKiAocGVyaW9kIC0gMSkgKyBsb3NzKSAvIHBlcmlvZDtcbiAgICB9XG5cbiAgICBpZiAoYXZnTG9zcyA9PT0gMCkgcmV0dXJuIDEwMDtcblxuICAgIGNvbnN0IHJzID0gYXZnR2FpbiAvIGF2Z0xvc3M7XG4gICAgY29uc3QgcnNpID0gMTAwIC0gMTAwIC8gKDEgKyBycyk7XG5cbiAgICByZXR1cm4gTWF0aC5yb3VuZChyc2kgKiAxMDApIC8gMTAwO1xuICB9XG5cbiAgLyoqXG4gICAqIOiuoeeul+eugOWNleenu+WKqOW5s+Wdh+e6vyAoU01BKVxuICAgKi9cbiAgcHJpdmF0ZSBjYWxjdWxhdGVTTUEocHJpY2VzOiBudW1iZXJbXSwgcGVyaW9kOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChwcmljZXMubGVuZ3RoIDwgcGVyaW9kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNNQSDorqHnrpfpnIDopoHoh7PlsJEgJHtwZXJpb2R9IOS4quS7t+agvOeCuWApO1xuICAgIH1cblxuICAgIGNvbnN0IHNsaWNlID0gcHJpY2VzLnNsaWNlKC1wZXJpb2QpO1xuICAgIGNvbnN0IHN1bSA9IHNsaWNlLnJlZHVjZSgoYWNjLCBwcmljZSkgPT4gYWNjICsgcHJpY2UsIDApO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKChzdW0gLyBwZXJpb2QpICogMTAwKSAvIDEwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiDorqHnrpfmjIfmlbDnp7vliqjlubPlnYfnur8gKEVNQSlcbiAgICovXG4gIHByaXZhdGUgY2FsY3VsYXRlRU1BKHByaWNlczogbnVtYmVyW10sIHBlcmlvZDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAocHJpY2VzLmxlbmd0aCA8IHBlcmlvZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFTUEg6K6h566X6ZyA6KaB6Iez5bCRICR7cGVyaW9kfSDkuKrku7fmoLzngrlgKTtcbiAgICB9XG5cbiAgICBjb25zdCBtdWx0aXBsaWVyID0gMiAvIChwZXJpb2QgKyAxKTtcbiAgICBsZXQgZW1hID0gcHJpY2VzLnNsaWNlKDAsIHBlcmlvZCkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBwZXJpb2Q7XG5cbiAgICBmb3IgKGxldCBpID0gcGVyaW9kOyBpIDwgcHJpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlbWEgPSAocHJpY2VzW2ldIC0gZW1hKSAqIG11bHRpcGxpZXIgKyBlbWE7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgucm91bmQoZW1hICogMTAwKSAvIDEwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiDorqHnrpfms6LliqjnjofvvIjku7fmoLzmoIflh4blt67vvIlcbiAgICovXG4gIHByaXZhdGUgY2FsY3VsYXRlVm9sYXRpbGl0eShwcmljZXM6IG51bWJlcltdLCBwZXJpb2Q6IG51bWJlciA9IDE0KTogbnVtYmVyIHtcbiAgICBpZiAocHJpY2VzLmxlbmd0aCA8IHBlcmlvZCkgcmV0dXJuIDA7XG5cbiAgICBjb25zdCBzbGljZSA9IHByaWNlcy5zbGljZSgtcGVyaW9kKTtcbiAgICBjb25zdCBtZWFuID0gc2xpY2UucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBwZXJpb2Q7XG4gICAgY29uc3Qgc3F1YXJlZERpZmZzID0gc2xpY2UubWFwKHByaWNlID0+IE1hdGgucG93KHByaWNlIC0gbWVhbiwgMikpO1xuICAgIGNvbnN0IHZhcmlhbmNlID0gc3F1YXJlZERpZmZzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gcGVyaW9kO1xuICAgIGNvbnN0IHN0ZERldiA9IE1hdGguc3FydCh2YXJpYW5jZSk7XG5cbiAgICAvLyDov5Tlm57nm7jlr7nms6LliqjnjofvvIjmoIflh4blt64v5Z2H5YC8ICogMTAw77yJXG4gICAgcmV0dXJuIE1hdGgucm91bmQoKHN0ZERldiAvIG1lYW4pICogMTAwICogMTAwKSAvIDEwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiDor4bliKvotovlir9cbiAgICovXG4gIHByaXZhdGUgaWRlbnRpZnlUcmVuZChwcmljZXM6IG51bWJlcltdKTogXCJ1cFwiIHwgXCJkb3duXCIgfCBcInNpZGV3YXlzXCIge1xuICAgIGlmIChwcmljZXMubGVuZ3RoIDwgMTQpIHJldHVybiBcInNpZGV3YXlzXCI7XG5cbiAgICBjb25zdCBtYTcgPSB0aGlzLmNhbGN1bGF0ZVNNQShwcmljZXMsIDcpO1xuICAgIGNvbnN0IG1hMTQgPSB0aGlzLmNhbGN1bGF0ZVNNQShwcmljZXMsIDE0KTtcbiAgICBjb25zdCBjdXJyZW50UHJpY2UgPSBwcmljZXNbcHJpY2VzLmxlbmd0aCAtIDFdO1xuXG4gICAgLy8g5Lu35qC855u45a+55LqO5Z2H57q/55qE5L2N572uXG4gICAgY29uc3QgYWJvdmVNYTcgPSBjdXJyZW50UHJpY2UgPiBtYTc7XG4gICAgY29uc3QgYWJvdmVNYTE0ID0gY3VycmVudFByaWNlID4gbWExNDtcbiAgICBjb25zdCBnb2xkZW5Dcm9zcyA9IG1hNyA+IG1hMTQ7XG5cbiAgICBpZiAoYWJvdmVNYTcgJiYgYWJvdmVNYTE0ICYmIGdvbGRlbkNyb3NzKSByZXR1cm4gXCJ1cFwiO1xuICAgIGlmICghYWJvdmVNYTcgJiYgIWFib3ZlTWExNCAmJiAhZ29sZGVuQ3Jvc3MpIHJldHVybiBcImRvd25cIjtcbiAgICByZXR1cm4gXCJzaWRld2F5c1wiO1xuICB9XG5cbiAgLyoqXG4gICAqIOiuoeeul+aUr+aSkeS9jeWSjOmYu+WKm+S9je+8iOeugOWNleWunueOsO+8iVxuICAgKi9cbiAgcHJpdmF0ZSBjYWxjdWxhdGVTdXBwb3J0UmVzaXN0YW5jZShcbiAgICBwcmljZXM6IG51bWJlcltdXG4gICk6IHsgc3VwcG9ydDogbnVtYmVyOyByZXNpc3RhbmNlOiBudW1iZXIgfSB7XG4gICAgY29uc3Qgd2luZG93ID0gMTA7XG4gICAgY29uc3QgcmVjZW50UHJpY2VzID0gcHJpY2VzLnNsaWNlKC13aW5kb3cgKiAzKTtcblxuICAgIGxldCBzdXBwb3J0ID0gTWF0aC5taW4oLi4ucmVjZW50UHJpY2VzKTtcbiAgICBsZXQgcmVzaXN0YW5jZSA9IE1hdGgubWF4KC4uLnJlY2VudFByaWNlcyk7XG5cbiAgICAvLyDnqI3lvq7osIPmlbTkvb/lhbbmm7TlkIjnkIZcbiAgICBzdXBwb3J0ID0gTWF0aC5yb3VuZChzdXBwb3J0ICogMC45OTUgKiAxMDApIC8gMTAwO1xuICAgIHJlc2lzdGFuY2UgPSBNYXRoLnJvdW5kKHJlc2lzdGFuY2UgKiAxLjAwNSAqIDEwMCkgLyAxMDA7XG5cbiAgICByZXR1cm4geyBzdXBwb3J0LCByZXNpc3RhbmNlIH07XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSDkv6Hlj7fnlJ/miJAgPT09PT09PT09PT09PT09PT09PT1cblxuICAvKipcbiAgICog5Z+65LqO5oqA5pyv5oyH5qCH55Sf5oiQ5Lqk5piT5L+h5Y+3XG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlU2lnbmFscyhcbiAgICBzeW1ib2w6IHN0cmluZyxcbiAgICBpbmRpY2F0b3JzOiBUZWNobmljYWxJbmRpY2F0b3JzLFxuICAgIHByaWNlczogbnVtYmVyW11cbiAgKTogVGVjaG5pY2FsU2lnbmFsW10ge1xuICAgIGNvbnN0IHNpZ25hbHM6IFRlY2huaWNhbFNpZ25hbFtdID0gW107XG5cbiAgICAvLyBSU0kg5L+h5Y+3XG4gICAgaWYgKGluZGljYXRvcnMucnNpID4gNzApIHtcbiAgICAgIHNpZ25hbHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwic2VsbFwiLFxuICAgICAgICBpbmRpY2F0b3I6IFwiUlNJXCIsXG4gICAgICAgIGNvbmZpZGVuY2U6IE1hdGgubWluKChpbmRpY2F0b3JzLnJzaSAtIDcwKSAvIDMwLCAxKSxcbiAgICAgICAgZGVzY3JpcHRpb246IGAke3N5bWJvbH0gUlNJIOi2heS5sCAoJHtpbmRpY2F0b3JzLnJzaX0pYCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaW5kaWNhdG9ycy5yc2kgPCAzMCkge1xuICAgICAgc2lnbmFscy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJidXlcIixcbiAgICAgICAgaW5kaWNhdG9yOiBcIlJTSVwiLFxuICAgICAgICBjb25maWRlbmNlOiBNYXRoLm1pbigoMzAgLSBpbmRpY2F0b3JzLnJzaSkgLyAzMCwgMSksXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgJHtzeW1ib2x9IFJTSSDotoXljZYgKCR7aW5kaWNhdG9ycy5yc2l9KWAsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyDnp7vliqjlubPlnYfnur/kv6Hlj7dcbiAgICBjb25zdCBjdXJyZW50UHJpY2UgPSBwcmljZXNbcHJpY2VzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChjdXJyZW50UHJpY2UgPiBpbmRpY2F0b3JzLm1hNyAmJiBpbmRpY2F0b3JzLm1hNyA+IGluZGljYXRvcnMubWExNCkge1xuICAgICAgc2lnbmFscy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJidXlcIixcbiAgICAgICAgaW5kaWNhdG9yOiBcIk1BIOi2i+WKv1wiLFxuICAgICAgICBjb25maWRlbmNlOiAwLjcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgJHtzeW1ib2x9IOS7t+agvOWcqCBNQTcg5LmL5LiK77yMTUE3IOWcqCBNQTE0IOS5i+S4iiAtIOeci+a2qOi2i+WKv2AsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRQcmljZSA8IGluZGljYXRvcnMubWE3ICYmIGluZGljYXRvcnMubWE3IDwgaW5kaWNhdG9ycy5tYTE0KSB7XG4gICAgICBzaWduYWxzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInNlbGxcIixcbiAgICAgICAgaW5kaWNhdG9yOiBcIk1BIOi2i+WKv1wiLFxuICAgICAgICBjb25maWRlbmNlOiAwLjcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgJHtzeW1ib2x9IOS7t+agvOWcqCBNQTcg5LmL5LiL77yMTUE3IOWcqCBNQTE0IOS5i+S4iyAtIOeci+i3jOi2i+WKv2AsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyDotovlir/kv6Hlj7dcbiAgICBpZiAoaW5kaWNhdG9ycy50cmVuZCA9PT0gXCJ1cFwiKSB7XG4gICAgICBzaWduYWxzLnB1c2goe1xuICAgICAgICB0eXBlOiBcImJ1eVwiLFxuICAgICAgICBpbmRpY2F0b3I6IFwi6LaL5Yq/XCIsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuNixcbiAgICAgICAgZGVzY3JpcHRpb246IGAke3N5bWJvbH0g5aSE5LqO5LiK5rao6LaL5Yq/YCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaW5kaWNhdG9ycy50cmVuZCA9PT0gXCJkb3duXCIpIHtcbiAgICAgIHNpZ25hbHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwic2VsbFwiLFxuICAgICAgICBpbmRpY2F0b3I6IFwi6LaL5Yq/XCIsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuNixcbiAgICAgICAgZGVzY3JpcHRpb246IGAke3N5bWJvbH0g5aSE5LqO5LiL6LeM6LaL5Yq/YCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIOWmguaenOayoeacieaYjuehruS/oeWPt++8jOi/lOWbnuS4reaAp1xuICAgIGlmIChzaWduYWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc2lnbmFscy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJuZXV0cmFsXCIsXG4gICAgICAgIGluZGljYXRvcjogXCLnu7zlkIhcIixcbiAgICAgICAgY29uZmlkZW5jZTogMC41LFxuICAgICAgICBkZXNjcmlwdGlvbjogYCR7c3ltYm9sfSDkv6Hlj7fmt7fmnYLvvIzmlrnlkJHkuI3mmI5gLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpZ25hbHM7XG4gIH1cblxuICAvKipcbiAgICog6K6h566X57u85ZCI6K+E5YiGXG4gICAqL1xuICBwcml2YXRlIGNhbGN1bGF0ZUNvbXBvc2l0ZVNjb3JlKGluZGljYXRvcnM6IFRlY2huaWNhbEluZGljYXRvcnMpOiBudW1iZXIge1xuICAgIGxldCBzY29yZSA9IDUwOyAvLyDln7rlh4bliIZcblxuICAgIC8vIFJTSSDotKHnjK4gKC0yMCB0byArMjApXG4gICAgc2NvcmUgKz0gKDUwIC0gaW5kaWNhdG9ycy5yc2kpICogMC40O1xuXG4gICAgLy8g6LaL5Yq/6LSh54yuXG4gICAgaWYgKGluZGljYXRvcnMudHJlbmQgPT09IFwidXBcIikgc2NvcmUgKz0gMTU7XG4gICAgaWYgKGluZGljYXRvcnMudHJlbmQgPT09IFwiZG93blwiKSBzY29yZSAtPSAxNTtcblxuICAgIC8vIOazouWKqOeOh+iwg+aVtO+8iOmrmOazouWKqOmZjeS9juS/oeW/g++8iVxuICAgIHNjb3JlIC09IGluZGljYXRvcnMudm9sYXRpbGl0eSAqIDAuMjtcblxuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIE1hdGgucm91bmQoc2NvcmUpKSk7XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSDlhazlhbHmlrnms5UgPT09PT09PT09PT09PT09PT09PT1cblxuICAvKipcbiAgICog5YiG5p6Q5Y2V5Liq5biB56eNXG4gICAqL1xuICBhc3luYyBhbmFseXplU3ltYm9sKHN5bWJvbDogc3RyaW5nLCBjb2luSWQ/OiBzdHJpbmcsIGRheXM6IHN0cmluZyA9IFwiMTRcIik6IFByb21pc2U8VGVjaG5pY2FsQW5hbHlzaXM+IHtcbiAgICBjb25zdCBpZCA9IGNvaW5JZCB8fCB0aGlzLmNvaW5JZE1hcFtzeW1ib2wudG9VcHBlckNhc2UoKV07XG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGDmnKrnn6XluIHnp406ICR7c3ltYm9sfWApO1xuICAgIH1cblxuICAgIC8vIOiOt+WPluW4guWcuuWbvuihqOaVsOaNrlxuICAgIGNvbnN0IGNoYXJ0RGF0YSA9IGF3YWl0IGdldENvaW5NYXJrZXRDaGFydChpZCwgZGF5cyk7XG4gICAgY29uc3QgcHJpY2VzID0gY2hhcnREYXRhLnByaWNlcy5tYXAocCA9PiBwWzFdKTtcblxuICAgIGlmIChwcmljZXMubGVuZ3RoIDwgMTQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzeW1ib2x9IOaVsOaNrueCueS4jei2s2ApO1xuICAgIH1cblxuICAgIC8vIOiuoeeul+aMh+agh1xuICAgIGNvbnN0IHJzaSA9IHRoaXMuY2FsY3VsYXRlUlNJKHByaWNlcyk7XG4gICAgY29uc3QgbWE3ID0gdGhpcy5jYWxjdWxhdGVTTUEocHJpY2VzLCA3KTtcbiAgICBjb25zdCBtYTE0ID0gdGhpcy5jYWxjdWxhdGVTTUEocHJpY2VzLCAxNCk7XG4gICAgY29uc3QgbWEzMCA9IHByaWNlcy5sZW5ndGggPj0gMzAgPyB0aGlzLmNhbGN1bGF0ZVNNQShwcmljZXMsIDMwKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCB2b2xhdGlsaXR5ID0gdGhpcy5jYWxjdWxhdGVWb2xhdGlsaXR5KHByaWNlcyk7XG4gICAgY29uc3QgdHJlbmQgPSB0aGlzLmlkZW50aWZ5VHJlbmQocHJpY2VzKTtcbiAgICBjb25zdCB7IHN1cHBvcnQsIHJlc2lzdGFuY2UgfSA9IHRoaXMuY2FsY3VsYXRlU3VwcG9ydFJlc2lzdGFuY2UocHJpY2VzKTtcblxuICAgIGNvbnN0IGluZGljYXRvcnM6IFRlY2huaWNhbEluZGljYXRvcnMgPSB7XG4gICAgICByc2ksXG4gICAgICBtYTcsXG4gICAgICBtYTE0LFxuICAgICAgbWEzMCxcbiAgICAgIHZvbGF0aWxpdHksXG4gICAgICB0cmVuZCxcbiAgICAgIHN1cHBvcnQsXG4gICAgICByZXNpc3RhbmNlLFxuICAgIH07XG5cbiAgICBjb25zdCBzaWduYWxzID0gdGhpcy5nZW5lcmF0ZVNpZ25hbHMoc3ltYm9sLCBpbmRpY2F0b3JzLCBwcmljZXMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN5bWJvbDogc3ltYm9sLnRvVXBwZXJDYXNlKCksXG4gICAgICBpbmRpY2F0b3JzLFxuICAgICAgc2lnbmFscyxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIOWIhuaekOWkmuS4quW4geenje+8iOeUqOS6juWumuaXtuS7u+WKoe+8iVxuICAgKi9cbiAgYXN5bmMgYW5hbHl6ZU11bHRpcGxlKHN5bWJvbHM6IHN0cmluZ1tdKTogUHJvbWlzZTxNdWx0aUFzc2V0QW5hbHlzaXM+IHtcbiAgICBjb25zdCBhbmFseXNlczogVGVjaG5pY2FsQW5hbHlzaXNbXSA9IFtdO1xuICAgIGNvbnN0IHByaWNlczogQXJyYXk8eyBzeW1ib2w6IHN0cmluZzsgcHJpY2U6IG51bWJlciB9PiA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBzeW1ib2wgb2Ygc3ltYm9scykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYW5hbHlzaXMgPSBhd2FpdCB0aGlzLmFuYWx5emVTeW1ib2woc3ltYm9sKTtcbiAgICAgICAgYW5hbHlzZXMucHVzaChhbmFseXNpcyk7XG4gICAgICAgIC8vIOiusOW9leW9k+WJjeS7t+agvFxuICAgICAgICBwcmljZXMucHVzaCh7XG4gICAgICAgICAgc3ltYm9sOiBhbmFseXNpcy5zeW1ib2wsXG4gICAgICAgICAgcHJpY2U6IGFuYWx5c2lzLmluZGljYXRvcnMubWE3LCAvLyDkvb/nlKggTUE3IOS9nOS4uui/keS8vOW9k+WJjeS7t+agvFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtUZWNoQW5hbHlzdF0gRmFpbGVkIHRvIGFuYWx5emUgJHtzeW1ib2x9OmAsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIC8vIOa3u+WKoOWwj+W7tui/n+mBv+WFjeivt+axgui/h+W/q1xuICAgICAgYXdhaXQgdGhpcy5kZWxheSg1MDApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhbmFseXNlcyxcbiAgICAgIHByaWNlcyxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIOW/q+mAn+WIhuaekCBCVEMg5ZKMIERPR0XvvIjmr4815YiG6ZKf6LCD55So77yJXG4gICAqL1xuICBhc3luYyBhbmFseXplQlRDQW5kRE9HRSgpOiBQcm9taXNlPE11bHRpQXNzZXRBbmFseXNpcz4ge1xuICAgIHJldHVybiB0aGlzLmFuYWx5emVNdWx0aXBsZShbXCJCVENcIiwgXCJET0dFXCJdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiDnlJ/miJDmioDmnK/mjIfmoIfmkZjopoFcbiAgICovXG4gIGdlbmVyYXRlU3VtbWFyeShhbmFseXNpczogVGVjaG5pY2FsQW5hbHlzaXMpOiBzdHJpbmcge1xuICAgIGNvbnN0IHsgc3ltYm9sLCBpbmRpY2F0b3JzLCBzaWduYWxzIH0gPSBhbmFseXNpcztcbiAgICBjb25zdCBjb21wb3NpdGVTY29yZSA9IHRoaXMuY2FsY3VsYXRlQ29tcG9zaXRlU2NvcmUoaW5kaWNhdG9ycyk7XG5cbiAgICBjb25zdCBidWxsaXNoU2lnbmFscyA9IHNpZ25hbHMuZmlsdGVyKHMgPT4gcy50eXBlID09PSBcImJ1eVwiIHx8IHMudHlwZSA9PT0gXCJzdHJvbmdfYnV5XCIpO1xuICAgIGNvbnN0IGJlYXJpc2hTaWduYWxzID0gc2lnbmFscy5maWx0ZXIocyA9PiBzLnR5cGUgPT09IFwic2VsbFwiIHx8IHMudHlwZSA9PT0gXCJzdHJvbmdfc2VsbFwiKTtcblxuICAgIGNvbnN0IHRyZW5kVGV4dCA9IGluZGljYXRvcnMudHJlbmQgPT09ICd1cCcgPyAn5LiK5raoJyA6IGluZGljYXRvcnMudHJlbmQgPT09ICdkb3duJyA/ICfkuIvot4wnIDogJ+aoquebmCc7XG5cbiAgICBsZXQgc3VtbWFyeSA9IGBbJHtzeW1ib2x9XSDmioDmnK/or4TliIY6ICR7Y29tcG9zaXRlU2NvcmV9LzEwMFxcbmA7XG4gICAgc3VtbWFyeSArPSBgUlNJOiAke2luZGljYXRvcnMucnNpfSB8IE1BNzogJCR7aW5kaWNhdG9ycy5tYTd9IHwgTUExNDogJCR7aW5kaWNhdG9ycy5tYTE0fVxcbmA7XG4gICAgc3VtbWFyeSArPSBg6LaL5Yq/OiAke3RyZW5kVGV4dH0gfCDms6Lliqjnjoc6ICR7aW5kaWNhdG9ycy52b2xhdGlsaXR5fSVcXG5gO1xuICAgIHN1bW1hcnkgKz0gYOS/oeWPtzogJHtidWxsaXNoU2lnbmFscy5sZW5ndGh9IOS4queci+a2qCwgJHtiZWFyaXNoU2lnbmFscy5sZW5ndGh9IOS4queci+i3jFxcbmA7XG5cbiAgICBpZiAoc2lnbmFscy5sZW5ndGggPiAwKSB7XG4gICAgICBzdW1tYXJ5ICs9IGDkuLvopoHkv6Hlj7c6ICR7c2lnbmFsc1swXS5kZXNjcmlwdGlvbn1gO1xuICAgIH1cblxuICAgIHJldHVybiBzdW1tYXJ5O1xuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0g5a6e546w5oq96LGh5pa55rOVID09PT09PT09PT09PT09PT09PT09XG5cbiAgYXN5bmMgZXhlY3V0ZVRhc2s8VD4odGFzazogQWdlbnRUYXNrKTogUHJvbWlzZTxUPiB7XG4gICAgc3dpdGNoICh0YXNrLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJhbmFseXplX3N5bWJvbFwiOiB7XG4gICAgICAgIGNvbnN0IHsgc3ltYm9sLCBjb2luSWQsIGRheXMgfSA9IHRhc2suZGF0YSBhcyBUZWNoQW5hbHlzaXNUYXNrO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmFuYWx5emVTeW1ib2woc3ltYm9sLCBjb2luSWQsIGRheXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0IGFzIFQ7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgXCJhbmFseXplX211bHRpcGxlXCI6IHtcbiAgICAgICAgY29uc3QgeyBzeW1ib2xzIH0gPSB0YXNrLmRhdGEgYXMgeyBzeW1ib2xzOiBzdHJpbmdbXSB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmFuYWx5emVNdWx0aXBsZShzeW1ib2xzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCBhcyBUO1xuICAgICAgfVxuXG4gICAgICBjYXNlIFwiYW5hbHl6ZV9idGNfZG9nZVwiOiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuYW5hbHl6ZUJUQ0FuZERPR0UoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCBhcyBUO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYOacquefpeeahOS7u+WKoeexu+WeizogJHt0YXNrLnR5cGV9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGdlbmVyYXRlUmVzcG9uc2UoXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIC8vIOaKgOacr+WIhuaekOWRmOS4u+imgeaYr+aVsOaNruWIhuaekO+8jOWvueivneWKn+iDveeugOWNleWunueOsFxuICAgIGlmIChtZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJhbmFseXplXCIpIHx8IG1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcIuWIhuaekFwiKSkge1xuICAgICAgY29uc3Qgc3ltYm9sID0gbWVzc2FnZS5tYXRjaCgvXFxiKEJUQ3xET0dFfEVUSHxTT0x8WFJQfEFEQSlcXGIvaSk/LlswXSB8fCBcIkJUQ1wiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYW5hbHlzaXMgPSBhd2FpdCB0aGlzLmFuYWx5emVTeW1ib2woc3ltYm9sKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVTdW1tYXJ5KGFuYWx5c2lzKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTXNnID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnJztcbiAgICAgICAgaWYgKGVycm9yTXNnLmluY2x1ZGVzKCc0MjknKSkge1xuICAgICAgICAgIHJldHVybiBg4o+zIEFQSSDor7fmsYLov4fkuo7popHnuYHvvIzor7fnrYnlvoUgMS0yIOWIhumSn+WQjuWGjeivleOAgmA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGDmirHmrYnvvIzmmoLml7bml6Dms5XliIbmnpAgJHtzeW1ib2x944CC6K+356iN5ZCO5YaN6K+V44CCYDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYOaIkeaYr+aKgOacr+WIhuaekOWRmO+8jOWPr+S7peW4ruS9oOWIhuaekOWKoOWvhui0p+W4geeahOaKgOacr+aMh+agh+OAguiuqeaIkeWIhuaekCBCVEPjgIFET0dFIOaIluWFtuS7luaUr+aMgeeahOW4geenjeOAgmA7XG4gIH1cbn1cblxuLy8g5Y2V5L6L5qih5byP5a+85Ye6XG5sZXQgdGVjaEFuYWx5c3RJbnN0YW5jZTogVGVjaG5pY2FsQW5hbHlzdCB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGVjaG5pY2FsQW5hbHlzdCgpOiBUZWNobmljYWxBbmFseXN0IHtcbiAgaWYgKCF0ZWNoQW5hbHlzdEluc3RhbmNlKSB7XG4gICAgdGVjaEFuYWx5c3RJbnN0YW5jZSA9IG5ldyBUZWNobmljYWxBbmFseXN0KCk7XG4gIH1cbiAgcmV0dXJuIHRlY2hBbmFseXN0SW5zdGFuY2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRlY2huaWNhbEFuYWx5c3Q7XG4iXSwibmFtZXMiOlsiQmFzZUFnZW50IiwiZ2V0Q29pbk1hcmtldENoYXJ0IiwiVGVjaG5pY2FsQW5hbHlzdCIsImNhbGN1bGF0ZVJTSSIsInByaWNlcyIsInBlcmlvZCIsImxlbmd0aCIsIkVycm9yIiwiZ2FpbnMiLCJsb3NzZXMiLCJpIiwiY2hhbmdlIiwiTWF0aCIsImFicyIsImF2Z0dhaW4iLCJhdmdMb3NzIiwiZ2FpbiIsImxvc3MiLCJycyIsInJzaSIsInJvdW5kIiwiY2FsY3VsYXRlU01BIiwic2xpY2UiLCJzdW0iLCJyZWR1Y2UiLCJhY2MiLCJwcmljZSIsImNhbGN1bGF0ZUVNQSIsIm11bHRpcGxpZXIiLCJlbWEiLCJhIiwiYiIsImNhbGN1bGF0ZVZvbGF0aWxpdHkiLCJtZWFuIiwic3F1YXJlZERpZmZzIiwibWFwIiwicG93IiwidmFyaWFuY2UiLCJzdGREZXYiLCJzcXJ0IiwiaWRlbnRpZnlUcmVuZCIsIm1hNyIsIm1hMTQiLCJjdXJyZW50UHJpY2UiLCJhYm92ZU1hNyIsImFib3ZlTWExNCIsImdvbGRlbkNyb3NzIiwiY2FsY3VsYXRlU3VwcG9ydFJlc2lzdGFuY2UiLCJ3aW5kb3ciLCJyZWNlbnRQcmljZXMiLCJzdXBwb3J0IiwibWluIiwicmVzaXN0YW5jZSIsIm1heCIsImdlbmVyYXRlU2lnbmFscyIsInN5bWJvbCIsImluZGljYXRvcnMiLCJzaWduYWxzIiwicHVzaCIsInR5cGUiLCJpbmRpY2F0b3IiLCJjb25maWRlbmNlIiwiZGVzY3JpcHRpb24iLCJ0cmVuZCIsImNhbGN1bGF0ZUNvbXBvc2l0ZVNjb3JlIiwic2NvcmUiLCJ2b2xhdGlsaXR5IiwiYW5hbHl6ZVN5bWJvbCIsImNvaW5JZCIsImRheXMiLCJpZCIsImNvaW5JZE1hcCIsInRvVXBwZXJDYXNlIiwiY2hhcnREYXRhIiwicCIsIm1hMzAiLCJ1bmRlZmluZWQiLCJ0aW1lc3RhbXAiLCJEYXRlIiwiYW5hbHl6ZU11bHRpcGxlIiwic3ltYm9scyIsImFuYWx5c2VzIiwiYW5hbHlzaXMiLCJlcnJvciIsImNvbnNvbGUiLCJkZWxheSIsImFuYWx5emVCVENBbmRET0dFIiwiZ2VuZXJhdGVTdW1tYXJ5IiwiY29tcG9zaXRlU2NvcmUiLCJidWxsaXNoU2lnbmFscyIsImZpbHRlciIsInMiLCJiZWFyaXNoU2lnbmFscyIsInRyZW5kVGV4dCIsInN1bW1hcnkiLCJleGVjdXRlVGFzayIsInRhc2siLCJkYXRhIiwicmVzdWx0IiwiZ2VuZXJhdGVSZXNwb25zZSIsIm1lc3NhZ2UiLCJjb250ZXh0IiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsIm1hdGNoIiwiZXJyb3JNc2ciLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJyb2xlIiwic3lzdGVtUHJvbXB0IiwiQlRDIiwiRE9HRSIsIkVUSCIsIlNPTCIsIlhSUCIsIkFEQSIsIkFWQVgiLCJET1QiLCJ0ZWNoQW5hbHlzdEluc3RhbmNlIiwiZ2V0VGVjaG5pY2FsQW5hbHlzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/agents/tech-analyst.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/data/coingecko.ts":
/*!*******************************!*\
  !*** ./lib/data/coingecko.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   COMMON_COINS: function() { return /* binding */ COMMON_COINS; },\n/* harmony export */   CoinGeckoError: function() { return /* binding */ CoinGeckoError; },\n/* harmony export */   getBTCAndDOGEData: function() { return /* binding */ getBTCAndDOGEData; },\n/* harmony export */   getCoinMarketChart: function() { return /* binding */ getCoinMarketChart; },\n/* harmony export */   getCoinOHLC: function() { return /* binding */ getCoinOHLC; },\n/* harmony export */   getCoinPrices: function() { return /* binding */ getCoinPrices; },\n/* harmony export */   getCoinsList: function() { return /* binding */ getCoinsList; },\n/* harmony export */   getCommonCoinPrices: function() { return /* binding */ getCommonCoinPrices; },\n/* harmony export */   getTrendingCoins: function() { return /* binding */ getTrendingCoins; },\n/* harmony export */   searchCoins: function() { return /* binding */ searchCoins; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * CoinGecko API 封装\n * 免费版限制：50 calls/minute\n * @see https://www.coingecko.com/api/documentation\n */ const COINGECKO_API_BASE = \"https://api.coingecko.com/api/v3\";\n// 代理配置（仅在 Node.js 环境使用）\n// 如果需要代理，请设置环境变量 HTTPS_PROXY，例如：\n// HTTPS_PROXY=http://127.0.0.1:10808 npm run dev\nconst PROXY_URL = process.env.HTTPS_PROXY || process.env.https_proxy || \"\";\nconst USE_PROXY = !!PROXY_URL;\n// 错误处理\nclass CoinGeckoError extends Error {\n    constructor(message, statusCode, response){\n        super(message);\n        this.statusCode = statusCode;\n        this.response = response;\n        this.name = \"CoinGeckoError\";\n    }\n}\n// 重试配置\nconst MAX_RETRIES = 3;\nconst INITIAL_RETRY_DELAY = 2000; // 2秒\n// 请求队列管理（限速保护）\nclass RequestQueue {\n    async add(fn) {\n        return new Promise((resolve, reject)=>{\n            this.queue.push(async ()=>{\n                try {\n                    // 限速控制\n                    const now = Date.now();\n                    const waitTime = Math.max(0, this.minInterval - (now - this.lastRequestTime));\n                    if (waitTime > 0) {\n                        await new Promise((r)=>setTimeout(r, waitTime));\n                    }\n                    this.lastRequestTime = Date.now();\n                    const result = await fn();\n                    resolve(result);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            if (!this.processing) {\n                this.processQueue();\n            }\n        });\n    }\n    async processQueue() {\n        this.processing = true;\n        while(this.queue.length > 0){\n            const task = this.queue.shift();\n            if (task) await task();\n        }\n        this.processing = false;\n    }\n    constructor(){\n        this.queue = [];\n        this.processing = false;\n        this.lastRequestTime = 0;\n        this.minInterval = 1200 // 1.2秒间隔（50 req/min = 1.2s/req）\n        ;\n    }\n}\nconst requestQueue = new RequestQueue();\n// 动态导入 node-fetch 和 https-proxy-agent（仅在服务器端）\nasync function getFetch() {\n    if (false) {}\n    // 浏览器端：使用原生 fetch\n    return fetch;\n}\nasync function getProxyAgent() {\n    if (false) {}\n    return undefined;\n}\n// 基础请求函数（带重试）\nasync function fetchCoinGecko(endpoint, params) {\n    return requestQueue.add(async ()=>{\n        let lastError = null;\n        for(let attempt = 0; attempt < MAX_RETRIES; attempt++){\n            try {\n                // 重试延迟（指数退避）\n                if (attempt > 0) {\n                    const delay = INITIAL_RETRY_DELAY * Math.pow(2, attempt - 1);\n                    console.log(\"[CoinGecko] 重试 \".concat(attempt + 1, \"/\").concat(MAX_RETRIES, \"，等待 \").concat(delay, \"ms...\"));\n                    await new Promise((r)=>setTimeout(r, delay));\n                }\n                const url = new URL(\"\".concat(COINGECKO_API_BASE).concat(endpoint));\n                if (params) {\n                    Object.entries(params).forEach((param)=>{\n                        let [key, value] = param;\n                        url.searchParams.append(key, value);\n                    });\n                }\n                // 构建 fetch 选项\n                const fetchOptions = {\n                    headers: {\n                        \"Accept\": \"application/json\"\n                    }\n                };\n                // 在 Node.js 环境中添加代理\n                if (false) {}\n                const fetchFn = await getFetch();\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const response = await fetchFn(url.toString(), fetchOptions);\n                if (!response.ok) {\n                    if (response.status === 429) {\n                        lastError = new CoinGeckoError(\"API 限速，稍等重试\", 429);\n                        continue; // 继续重试\n                    }\n                    const errorText = await response.text();\n                    throw new CoinGeckoError(\"CoinGecko API error: \".concat(response.status, \" - \").concat(errorText), response.status);\n                }\n                return await response.json();\n            } catch (error) {\n                if (error instanceof CoinGeckoError && error.statusCode === 429) {\n                    lastError = error;\n                    continue; // 继续重试\n                }\n                throw error; // 其他错误直接抛出\n            }\n        }\n        // 所有重试都失败了\n        throw lastError || new CoinGeckoError(\"请求失败，请稍后再试\");\n    });\n}\n// ==================== API 方法 ====================\n/**\n * 获取多个币种的当前市场价格\n * @param ids 币种ID数组，如 [\"bitcoin\", \"dogecoin\"]\n * @param vsCurrency 计价货币，默认 \"usd\"\n */ async function getCoinPrices(ids) {\n    let vsCurrency = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"usd\";\n    return fetchCoinGecko(\"/coins/markets\", {\n        vs_currency: vsCurrency,\n        ids: ids.join(\",\"),\n        order: \"market_cap_desc\",\n        per_page: ids.length.toString(),\n        page: \"1\",\n        sparkline: \"false\",\n        price_change_percentage: \"24h\"\n    });\n}\n/**\n * 获取单个币种的历史价格数据\n * @param id 币种ID，如 \"bitcoin\"\n * @param days 天数（1, 7, 14, 30, 90, 180, 365, max）\n * @param vsCurrency 计价货币\n */ async function getCoinMarketChart(id) {\n    let days = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"7\", vsCurrency = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"usd\";\n    return fetchCoinGecko(\"/coins/\".concat(id, \"/market_chart\"), {\n        vs_currency: vsCurrency,\n        days\n    });\n}\n/**\n * 获取 OHLC 数据（用于技术分析）\n * @param id 币种ID\n * @param days 天数（1, 7, 14, 30, 90, 180, 365）\n * @param vsCurrency 计价货币\n */ async function getCoinOHLC(id) {\n    let days = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"7\", vsCurrency = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"usd\";\n    return fetchCoinGecko(\"/coins/\".concat(id, \"/ohlc\"), {\n        vs_currency: vsCurrency,\n        days\n    });\n}\n/**\n * 获取支持的币种列表\n * @param includePlatform 是否包含平台信息\n */ async function getCoinsList() {\n    let includePlatform = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    return fetchCoinGecko(\"/coins/list\", {\n        include_platform: includePlatform.toString()\n    });\n}\n/**\n * 获取趋势币种（热门搜索）\n */ async function getTrendingCoins() {\n    return fetchCoinGecko(\"/search/trending\");\n}\n/**\n * 搜索币种\n * @param query 搜索关键词\n */ async function searchCoins(query) {\n    return fetchCoinGecko(\"/search\", {\n        query\n    });\n}\n// ==================== 常用币种快捷方法 ====================\nconst COMMON_COINS = {\n    BTC: \"bitcoin\",\n    ETH: \"ethereum\",\n    DOGE: \"dogecoin\",\n    SOL: \"solana\",\n    XRP: \"ripple\",\n    ADA: \"cardano\",\n    AVAX: \"avalanche-2\",\n    DOT: \"polkadot\",\n    MATIC: \"matic-network\",\n    LINK: \"chainlink\"\n};\n/**\n * 获取常用币种价格\n */ async function getCommonCoinPrices() {\n    let symbols = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [\n        \"BTC\",\n        \"DOGE\"\n    ];\n    const ids = symbols.map((s)=>COMMON_COINS[s]);\n    return getCoinPrices(ids);\n}\n/**\n * 获取 BTC 和 DOGE 的价格和技术数据\n * 用于定时任务\n */ async function getBTCAndDOGEData() {\n    const [prices, btcChart, dogeChart] = await Promise.all([\n        getCommonCoinPrices([\n            \"BTC\",\n            \"DOGE\"\n        ]),\n        getCoinMarketChart(\"bitcoin\", \"14\"),\n        getCoinMarketChart(\"dogecoin\", \"14\")\n    ]);\n    return {\n        prices,\n        btcChart,\n        dogeChart\n    };\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    getCoinPrices,\n    getCoinMarketChart,\n    getCoinOHLC,\n    getCoinsList,\n    getTrendingCoins,\n    searchCoins,\n    getCommonCoinPrices,\n    getBTCAndDOGEData\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9kYXRhL2NvaW5nZWNrby50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FFRCxNQUFNQSxxQkFBcUI7QUFFM0Isd0JBQXdCO0FBQ3hCLGlDQUFpQztBQUNqQyxpREFBaUQ7QUFDakQsTUFBTUMsWUFBWUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxXQUFXLElBQUlGLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0UsV0FBVyxJQUFJO0FBQ3hFLE1BQU1DLFlBQVksQ0FBQyxDQUFDTDtBQXlCcEIsT0FBTztBQUNQLE1BQU1NLHVCQUF1QkM7SUFDM0JDLFlBQ0VDLE9BQWUsRUFDZixVQUEwQixFQUMxQixRQUF5QixDQUN6QjtRQUNBLEtBQUssQ0FBQ0E7YUFIQ0MsYUFBQUE7YUFDQUMsV0FBQUE7UUFHUCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQSxPQUFPO0FBQ1AsTUFBTUMsY0FBYztBQUNwQixNQUFNQyxzQkFBc0IsTUFBTSxLQUFLO0FBRXZDLGVBQWU7QUFDZixNQUFNQztJQU1KLE1BQU1DLElBQU9DLEVBQW9CLEVBQWM7UUFDN0MsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1lBQzNCLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQUM7Z0JBQ2QsSUFBSTtvQkFDRixPQUFPO29CQUNQLE1BQU1DLE1BQU1DLEtBQUtELEdBQUc7b0JBQ3BCLE1BQU1FLFdBQVdDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQ0MsV0FBVyxHQUFJTCxDQUFBQSxNQUFNLElBQUksQ0FBQ00sZUFBZTtvQkFDM0UsSUFBSUosV0FBVyxHQUFHO3dCQUNoQixNQUFNLElBQUlQLFFBQVFZLENBQUFBLElBQUtDLFdBQVdELEdBQUdMO29CQUN2QztvQkFDQSxJQUFJLENBQUNJLGVBQWUsR0FBR0wsS0FBS0QsR0FBRztvQkFFL0IsTUFBTVMsU0FBUyxNQUFNZjtvQkFDckJFLFFBQVFh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UEMsTUFBTTtBQUNSO0FBSUE7O0NBRUMsR0FDTSxlQUFlQztRQUNwQkMsVUFBQUEsaUVBQThCO1FBQUM7UUFBTztLQUFPO0lBRTdDLE1BQU0vQixNQUFNK0IsUUFBUUMsR0FBRyxDQUFDQyxDQUFBQSxJQUFLZCxZQUFZLENBQUNjLEVBQUU7SUFDNUMsT0FBT2xDLGNBQWNDO0FBQ3ZCO0FBRUE7OztDQUdDLEdBQ00sZUFBZWtDO0lBS3BCLE1BQU0sQ0FBQ0MsUUFBUUMsVUFBVUMsVUFBVSxHQUFHLE1BQU0vRixRQUFRZ0csR0FBRyxDQUFDO1FBQ3REUixvQkFBb0I7WUFBQztZQUFPO1NBQU87UUFDbkNyQixtQkFBbUIsV0FBVztRQUM5QkEsbUJBQW1CLFlBQVk7S0FDaEM7SUFFRCxPQUFPO1FBQUUwQjtRQUFRQztRQUFVQztJQUFVO0FBQ3ZDO0FBRXdDO0FBQ3hDLCtEQUFlO0lBQ2J0QztJQUNBVTtJQUNBRztJQUNBQztJQUNBRztJQUNBQztJQUNBYTtJQUNBSTtBQUNGLENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvZGF0YS9jb2luZ2Vja28udHM/OTE0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvaW5HZWNrbyBBUEkg5bCB6KOFXG4gKiDlhY3otLnniYjpmZDliLbvvJo1MCBjYWxscy9taW51dGVcbiAqIEBzZWUgaHR0cHM6Ly93d3cuY29pbmdlY2tvLmNvbS9hcGkvZG9jdW1lbnRhdGlvblxuICovXG5cbmNvbnN0IENPSU5HRUNLT19BUElfQkFTRSA9IFwiaHR0cHM6Ly9hcGkuY29pbmdlY2tvLmNvbS9hcGkvdjNcIjtcblxuLy8g5Luj55CG6YWN572u77yI5LuF5ZyoIE5vZGUuanMg546v5aKD5L2/55So77yJXG4vLyDlpoLmnpzpnIDopoHku6PnkIbvvIzor7forr7nva7njq/looPlj5jph48gSFRUUFNfUFJPWFnvvIzkvovlpoLvvJpcbi8vIEhUVFBTX1BST1hZPWh0dHA6Ly8xMjcuMC4wLjE6MTA4MDggbnBtIHJ1biBkZXZcbmNvbnN0IFBST1hZX1VSTCA9IHByb2Nlc3MuZW52LkhUVFBTX1BST1hZIHx8IHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5IHx8IFwiXCI7XG5jb25zdCBVU0VfUFJPWFkgPSAhIVBST1hZX1VSTDtcblxuZXhwb3J0IGludGVyZmFjZSBDb2luUHJpY2Uge1xuICBpZDogc3RyaW5nO1xuICBzeW1ib2w6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBjdXJyZW50X3ByaWNlOiBudW1iZXI7XG4gIHByaWNlX2NoYW5nZV8yNGg6IG51bWJlcjtcbiAgcHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfMjRoOiBudW1iZXI7XG4gIG1hcmtldF9jYXA6IG51bWJlcjtcbiAgdG90YWxfdm9sdW1lOiBudW1iZXI7XG4gIGxhc3RfdXBkYXRlZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvaW5NYXJrZXRDaGFydCB7XG4gIHByaWNlczogW251bWJlciwgbnVtYmVyXVtdOyAvLyBbdGltZXN0YW1wLCBwcmljZV1cbiAgbWFya2V0X2NhcHM6IFtudW1iZXIsIG51bWJlcl1bXTtcbiAgdG90YWxfdm9sdW1lczogW251bWJlciwgbnVtYmVyXVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvaW5PSExDIHtcbiAgLy8gW3RpbWVzdGFtcCwgb3BlbiwgaGlnaCwgbG93LCBjbG9zZV1cbiAgW2luZGV4OiBudW1iZXJdOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xufVxuXG4vLyDplJnor6/lpITnkIZcbmNsYXNzIENvaW5HZWNrb0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgcHVibGljIHN0YXR1c0NvZGU/OiBudW1iZXIsXG4gICAgcHVibGljIHJlc3BvbnNlPzogdW5rbm93blxuICApIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkNvaW5HZWNrb0Vycm9yXCI7XG4gIH1cbn1cblxuLy8g6YeN6K+V6YWN572uXG5jb25zdCBNQVhfUkVUUklFUyA9IDM7XG5jb25zdCBJTklUSUFMX1JFVFJZX0RFTEFZID0gMjAwMDsgLy8gMuenklxuXG4vLyDor7fmsYLpmJ/liJfnrqHnkIbvvIjpmZDpgJ/kv53miqTvvIlcbmNsYXNzIFJlcXVlc3RRdWV1ZSB7XG4gIHByaXZhdGUgcXVldWU6ICgoKSA9PiB2b2lkKVtdID0gW107XG4gIHByaXZhdGUgcHJvY2Vzc2luZyA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3RSZXF1ZXN0VGltZSA9IDA7XG4gIHByaXZhdGUgcmVhZG9ubHkgbWluSW50ZXJ2YWwgPSAxMjAwOyAvLyAxLjLnp5Lpl7TpmpTvvIg1MCByZXEvbWluID0gMS4ycy9yZXHvvIlcblxuICBhc3luYyBhZGQ8VD4oZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5xdWV1ZS5wdXNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyDpmZDpgJ/mjqfliLZcbiAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIGNvbnN0IHdhaXRUaW1lID0gTWF0aC5tYXgoMCwgdGhpcy5taW5JbnRlcnZhbCAtIChub3cgLSB0aGlzLmxhc3RSZXF1ZXN0VGltZSkpO1xuICAgICAgICAgIGlmICh3YWl0VGltZSA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCB3YWl0VGltZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxhc3RSZXF1ZXN0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oKTtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghdGhpcy5wcm9jZXNzaW5nKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1F1ZXVlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHByb2Nlc3NRdWV1ZSgpIHtcbiAgICB0aGlzLnByb2Nlc3NpbmcgPSB0cnVlO1xuICAgIHdoaWxlICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRhc2sgPSB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICBpZiAodGFzaykgYXdhaXQgdGFzaygpO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxufVxuXG5jb25zdCByZXF1ZXN0UXVldWUgPSBuZXcgUmVxdWVzdFF1ZXVlKCk7XG5cbi8vIOWKqOaAgeWvvOWFpSBub2RlLWZldGNoIOWSjCBodHRwcy1wcm94eS1hZ2VudO+8iOS7heWcqOacjeWKoeWZqOerr++8iVxuYXN5bmMgZnVuY3Rpb24gZ2V0RmV0Y2goKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8g5pyN5Yqh5Zmo56uv77ya5L2/55SoIG5vZGUtZmV0Y2hcbiAgICBjb25zdCB7IGRlZmF1bHQ6IG5vZGVGZXRjaCB9ID0gYXdhaXQgaW1wb3J0KFwibm9kZS1mZXRjaFwiKTtcbiAgICByZXR1cm4gbm9kZUZldGNoO1xuICB9XG4gIC8vIOa1j+iniOWZqOerr++8muS9v+eUqOWOn+eUnyBmZXRjaFxuICByZXR1cm4gZmV0Y2g7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFByb3h5QWdlbnQoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiICYmIFVTRV9QUk9YWSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IEh0dHBzUHJveHlBZ2VudCB9ID0gYXdhaXQgaW1wb3J0KFwiaHR0cHMtcHJveHktYWdlbnRcIik7XG4gICAgICByZXR1cm4gbmV3IEh0dHBzUHJveHlBZ2VudChQUk9YWV9VUkwpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLy8g5Z+656GA6K+35rGC5Ye95pWw77yI5bim6YeN6K+V77yJXG5hc3luYyBmdW5jdGlvbiBmZXRjaENvaW5HZWNrbzxUPihlbmRwb2ludDogc3RyaW5nLCBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogUHJvbWlzZTxUPiB7XG4gIHJldHVybiByZXF1ZXN0UXVldWUuYWRkKGFzeW5jICgpID0+IHtcbiAgICBsZXQgbGFzdEVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xuICAgIFxuICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgTUFYX1JFVFJJRVM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8g6YeN6K+V5bu26L+f77yI5oyH5pWw6YCA6YG/77yJXG4gICAgICAgIGlmIChhdHRlbXB0ID4gMCkge1xuICAgICAgICAgIGNvbnN0IGRlbGF5ID0gSU5JVElBTF9SRVRSWV9ERUxBWSAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0NvaW5HZWNrb10g6YeN6K+VICR7YXR0ZW1wdCArIDF9LyR7TUFYX1JFVFJJRVN977yM562J5b6FICR7ZGVsYXl9bXMuLi5gKTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHNldFRpbWVvdXQociwgZGVsYXkpKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtDT0lOR0VDS09fQVBJX0JBU0V9JHtlbmRwb2ludH1gKTtcbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOaehOW7uiBmZXRjaCDpgInpoblcbiAgICAgICAgY29uc3QgZmV0Y2hPcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkFjY2VwdFwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIOWcqCBOb2RlLmpzIOeOr+Wig+S4rea3u+WKoOS7o+eQhlxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGNvbnN0IGFnZW50ID0gYXdhaXQgZ2V0UHJveHlBZ2VudCgpO1xuICAgICAgICAgIGlmIChhZ2VudCkge1xuICAgICAgICAgICAgKGZldGNoT3B0aW9ucyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikuYWdlbnQgPSBhZ2VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmZXRjaEZuID0gYXdhaXQgZ2V0RmV0Y2goKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEZuKHVybC50b1N0cmluZygpLCBmZXRjaE9wdGlvbnMgYXMgYW55KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICAgICAgICBsYXN0RXJyb3IgPSBuZXcgQ29pbkdlY2tvRXJyb3IoXCJBUEkg6ZmQ6YCf77yM56iN562J6YeN6K+VXCIsIDQyOSk7XG4gICAgICAgICAgICBjb250aW51ZTsgLy8g57un57ut6YeN6K+VXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICB0aHJvdyBuZXcgQ29pbkdlY2tvRXJyb3IoXG4gICAgICAgICAgICBgQ29pbkdlY2tvIEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9IC0gJHtlcnJvclRleHR9YCxcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpIGFzIFQ7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDb2luR2Vja29FcnJvciAmJiBlcnJvci5zdGF0dXNDb2RlID09PSA0MjkpIHtcbiAgICAgICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICBjb250aW51ZTsgLy8g57un57ut6YeN6K+VXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7IC8vIOWFtuS7lumUmeivr+ebtOaOpeaKm+WHulxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyDmiYDmnInph43or5Xpg73lpLHotKXkuoZcbiAgICB0aHJvdyBsYXN0RXJyb3IgfHwgbmV3IENvaW5HZWNrb0Vycm9yKFwi6K+35rGC5aSx6LSl77yM6K+356iN5ZCO5YaN6K+VXCIpO1xuICB9KTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT0gQVBJIOaWueazlSA9PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIOiOt+WPluWkmuS4quW4geenjeeahOW9k+WJjeW4guWcuuS7t+agvFxuICogQHBhcmFtIGlkcyDluIHnp41JROaVsOe7hO+8jOWmgiBbXCJiaXRjb2luXCIsIFwiZG9nZWNvaW5cIl1cbiAqIEBwYXJhbSB2c0N1cnJlbmN5IOiuoeS7t+i0p+W4ge+8jOm7mOiupCBcInVzZFwiXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb2luUHJpY2VzKFxuICBpZHM6IHN0cmluZ1tdLFxuICB2c0N1cnJlbmN5OiBzdHJpbmcgPSBcInVzZFwiXG4pOiBQcm9taXNlPENvaW5QcmljZVtdPiB7XG4gIHJldHVybiBmZXRjaENvaW5HZWNrbzxDb2luUHJpY2VbXT4oXCIvY29pbnMvbWFya2V0c1wiLCB7XG4gICAgdnNfY3VycmVuY3k6IHZzQ3VycmVuY3ksXG4gICAgaWRzOiBpZHMuam9pbihcIixcIiksXG4gICAgb3JkZXI6IFwibWFya2V0X2NhcF9kZXNjXCIsXG4gICAgcGVyX3BhZ2U6IGlkcy5sZW5ndGgudG9TdHJpbmcoKSxcbiAgICBwYWdlOiBcIjFcIixcbiAgICBzcGFya2xpbmU6IFwiZmFsc2VcIixcbiAgICBwcmljZV9jaGFuZ2VfcGVyY2VudGFnZTogXCIyNGhcIixcbiAgfSk7XG59XG5cbi8qKlxuICog6I635Y+W5Y2V5Liq5biB56eN55qE5Y6G5Y+y5Lu35qC85pWw5o2uXG4gKiBAcGFyYW0gaWQg5biB56eNSUTvvIzlpoIgXCJiaXRjb2luXCJcbiAqIEBwYXJhbSBkYXlzIOWkqeaVsO+8iDEsIDcsIDE0LCAzMCwgOTAsIDE4MCwgMzY1LCBtYXjvvIlcbiAqIEBwYXJhbSB2c0N1cnJlbmN5IOiuoeS7t+i0p+W4gVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29pbk1hcmtldENoYXJ0KFxuICBpZDogc3RyaW5nLFxuICBkYXlzOiBzdHJpbmcgPSBcIjdcIixcbiAgdnNDdXJyZW5jeTogc3RyaW5nID0gXCJ1c2RcIlxuKTogUHJvbWlzZTxDb2luTWFya2V0Q2hhcnQ+IHtcbiAgcmV0dXJuIGZldGNoQ29pbkdlY2tvPENvaW5NYXJrZXRDaGFydD4oYC9jb2lucy8ke2lkfS9tYXJrZXRfY2hhcnRgLCB7XG4gICAgdnNfY3VycmVuY3k6IHZzQ3VycmVuY3ksXG4gICAgZGF5cyxcbiAgfSk7XG59XG5cbi8qKlxuICog6I635Y+WIE9ITEMg5pWw5o2u77yI55So5LqO5oqA5pyv5YiG5p6Q77yJXG4gKiBAcGFyYW0gaWQg5biB56eNSURcbiAqIEBwYXJhbSBkYXlzIOWkqeaVsO+8iDEsIDcsIDE0LCAzMCwgOTAsIDE4MCwgMzY177yJXG4gKiBAcGFyYW0gdnNDdXJyZW5jeSDorqHku7fotKfluIFcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvaW5PSExDKFxuICBpZDogc3RyaW5nLFxuICBkYXlzOiBzdHJpbmcgPSBcIjdcIixcbiAgdnNDdXJyZW5jeTogc3RyaW5nID0gXCJ1c2RcIlxuKTogUHJvbWlzZTxbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdW10+IHtcbiAgcmV0dXJuIGZldGNoQ29pbkdlY2tvPFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl1bXT4oXG4gICAgYC9jb2lucy8ke2lkfS9vaGxjYCxcbiAgICB7XG4gICAgICB2c19jdXJyZW5jeTogdnNDdXJyZW5jeSxcbiAgICAgIGRheXMsXG4gICAgfVxuICApO1xufVxuXG4vKipcbiAqIOiOt+WPluaUr+aMgeeahOW4geenjeWIl+ihqFxuICogQHBhcmFtIGluY2x1ZGVQbGF0Zm9ybSDmmK/lkKbljIXlkKvlubPlj7Dkv6Hmga9cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvaW5zTGlzdChpbmNsdWRlUGxhdGZvcm06IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8XG4gIHsgaWQ6IHN0cmluZzsgc3ltYm9sOiBzdHJpbmc7IG5hbWU6IHN0cmluZzsgcGxhdGZvcm1zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB9W11cbj4ge1xuICByZXR1cm4gZmV0Y2hDb2luR2Vja28oYC9jb2lucy9saXN0YCwge1xuICAgIGluY2x1ZGVfcGxhdGZvcm06IGluY2x1ZGVQbGF0Zm9ybS50b1N0cmluZygpLFxuICB9KTtcbn1cblxuLyoqXG4gKiDojrflj5botovlir/luIHnp43vvIjng63pl6jmkJzntKLvvIlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRyZW5kaW5nQ29pbnMoKTogUHJvbWlzZTx7XG4gIGNvaW5zOiB7XG4gICAgaXRlbToge1xuICAgICAgaWQ6IHN0cmluZztcbiAgICAgIGNvaW5faWQ6IG51bWJlcjtcbiAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgIHN5bWJvbDogc3RyaW5nO1xuICAgICAgbWFya2V0X2NhcF9yYW5rOiBudW1iZXI7XG4gICAgICB0aHVtYjogc3RyaW5nO1xuICAgICAgc21hbGw6IHN0cmluZztcbiAgICAgIGxhcmdlOiBzdHJpbmc7XG4gICAgICBzbHVnOiBzdHJpbmc7XG4gICAgICBwcmljZV9idGM6IG51bWJlcjtcbiAgICAgIHNjb3JlOiBudW1iZXI7XG4gICAgfTtcbiAgfVtdO1xufT4ge1xuICByZXR1cm4gZmV0Y2hDb2luR2Vja28oXCIvc2VhcmNoL3RyZW5kaW5nXCIpO1xufVxuXG4vKipcbiAqIOaQnOe0ouW4geenjVxuICogQHBhcmFtIHF1ZXJ5IOaQnOe0ouWFs+mUruivjVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VhcmNoQ29pbnMocXVlcnk6IHN0cmluZyk6IFByb21pc2U8e1xuICBjb2luczoge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHN5bWJvbDogc3RyaW5nO1xuICAgIG1hcmtldF9jYXBfcmFuazogbnVtYmVyO1xuICAgIHRodW1iOiBzdHJpbmc7XG4gICAgbGFyZ2U6IHN0cmluZztcbiAgfVtdO1xufT4ge1xuICByZXR1cm4gZmV0Y2hDb2luR2Vja28oXCIvc2VhcmNoXCIsIHsgcXVlcnkgfSk7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09IOW4uOeUqOW4geenjeW/q+aNt+aWueazlSA9PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBDT01NT05fQ09JTlMgPSB7XG4gIEJUQzogXCJiaXRjb2luXCIsXG4gIEVUSDogXCJldGhlcmV1bVwiLFxuICBET0dFOiBcImRvZ2Vjb2luXCIsXG4gIFNPTDogXCJzb2xhbmFcIixcbiAgWFJQOiBcInJpcHBsZVwiLFxuICBBREE6IFwiY2FyZGFub1wiLFxuICBBVkFYOiBcImF2YWxhbmNoZS0yXCIsXG4gIERPVDogXCJwb2xrYWRvdFwiLFxuICBNQVRJQzogXCJtYXRpYy1uZXR3b3JrXCIsXG4gIExJTks6IFwiY2hhaW5saW5rXCIsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgdHlwZSBDb21tb25Db2luU3ltYm9sID0ga2V5b2YgdHlwZW9mIENPTU1PTl9DT0lOUztcblxuLyoqXG4gKiDojrflj5bluLjnlKjluIHnp43ku7fmoLxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvbW1vbkNvaW5QcmljZXMoXG4gIHN5bWJvbHM6IENvbW1vbkNvaW5TeW1ib2xbXSA9IFtcIkJUQ1wiLCBcIkRPR0VcIl1cbik6IFByb21pc2U8Q29pblByaWNlW10+IHtcbiAgY29uc3QgaWRzID0gc3ltYm9scy5tYXAocyA9PiBDT01NT05fQ09JTlNbc10pO1xuICByZXR1cm4gZ2V0Q29pblByaWNlcyhpZHMpO1xufVxuXG4vKipcbiAqIOiOt+WPliBCVEMg5ZKMIERPR0Ug55qE5Lu35qC85ZKM5oqA5pyv5pWw5o2uXG4gKiDnlKjkuo7lrprml7bku7vliqFcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJUQ0FuZERPR0VEYXRhKCk6IFByb21pc2U8e1xuICBwcmljZXM6IENvaW5QcmljZVtdO1xuICBidGNDaGFydDogQ29pbk1hcmtldENoYXJ0O1xuICBkb2dlQ2hhcnQ6IENvaW5NYXJrZXRDaGFydDtcbn0+IHtcbiAgY29uc3QgW3ByaWNlcywgYnRjQ2hhcnQsIGRvZ2VDaGFydF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgZ2V0Q29tbW9uQ29pblByaWNlcyhbXCJCVENcIiwgXCJET0dFXCJdKSxcbiAgICBnZXRDb2luTWFya2V0Q2hhcnQoXCJiaXRjb2luXCIsIFwiMTRcIiksIC8vIDE05aSp5pWw5o2u55So5LqO6K6h566XTUFcbiAgICBnZXRDb2luTWFya2V0Q2hhcnQoXCJkb2dlY29pblwiLCBcIjE0XCIpLFxuICBdKTtcblxuICByZXR1cm4geyBwcmljZXMsIGJ0Y0NoYXJ0LCBkb2dlQ2hhcnQgfTtcbn1cblxuZXhwb3J0IHsgQ29pbkdlY2tvRXJyb3IsIENPTU1PTl9DT0lOUyB9O1xuZXhwb3J0IGRlZmF1bHQge1xuICBnZXRDb2luUHJpY2VzLFxuICBnZXRDb2luTWFya2V0Q2hhcnQsXG4gIGdldENvaW5PSExDLFxuICBnZXRDb2luc0xpc3QsXG4gIGdldFRyZW5kaW5nQ29pbnMsXG4gIHNlYXJjaENvaW5zLFxuICBnZXRDb21tb25Db2luUHJpY2VzLFxuICBnZXRCVENBbmRET0dFRGF0YSxcbn07XG4iXSwibmFtZXMiOlsiQ09JTkdFQ0tPX0FQSV9CQVNFIiwiUFJPWFlfVVJMIiwicHJvY2VzcyIsImVudiIsIkhUVFBTX1BST1hZIiwiaHR0cHNfcHJveHkiLCJVU0VfUFJPWFkiLCJDb2luR2Vja29FcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwic3RhdHVzQ29kZSIsInJlc3BvbnNlIiwibmFtZSIsIk1BWF9SRVRSSUVTIiwiSU5JVElBTF9SRVRSWV9ERUxBWSIsIlJlcXVlc3RRdWV1ZSIsImFkZCIsImZuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJxdWV1ZSIsInB1c2giLCJub3ciLCJEYXRlIiwid2FpdFRpbWUiLCJNYXRoIiwibWF4IiwibWluSW50ZXJ2YWwiLCJsYXN0UmVxdWVzdFRpbWUiLCJyIiwic2V0VGltZW91dCIsInJlc3VsdCIsImVycm9yIiwicHJvY2Vzc2luZyIsInByb2Nlc3NRdWV1ZSIsImxlbmd0aCIsInRhc2siLCJzaGlmdCIsInJlcXVlc3RRdWV1ZSIsImdldEZldGNoIiwiZGVmYXVsdCIsIm5vZGVGZXRjaCIsImZldGNoIiwiZ2V0UHJveHlBZ2VudCIsIkh0dHBzUHJveHlBZ2VudCIsInVuZGVmaW5lZCIsImZldGNoQ29pbkdlY2tvIiwiZW5kcG9pbnQiLCJwYXJhbXMiLCJsYXN0RXJyb3IiLCJhdHRlbXB0IiwiZGVsYXkiLCJwb3ciLCJjb25zb2xlIiwibG9nIiwidXJsIiwiVVJMIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsInNlYXJjaFBhcmFtcyIsImFwcGVuZCIsImZldGNoT3B0aW9ucyIsImhlYWRlcnMiLCJhZ2VudCIsImZldGNoRm4iLCJ0b1N0cmluZyIsIm9rIiwic3RhdHVzIiwiZXJyb3JUZXh0IiwidGV4dCIsImpzb24iLCJnZXRDb2luUHJpY2VzIiwiaWRzIiwidnNDdXJyZW5jeSIsInZzX2N1cnJlbmN5Iiwiam9pbiIsIm9yZGVyIiwicGVyX3BhZ2UiLCJwYWdlIiwic3BhcmtsaW5lIiwicHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2UiLCJnZXRDb2luTWFya2V0Q2hhcnQiLCJpZCIsImRheXMiLCJnZXRDb2luT0hMQyIsImdldENvaW5zTGlzdCIsImluY2x1ZGVQbGF0Zm9ybSIsImluY2x1ZGVfcGxhdGZvcm0iLCJnZXRUcmVuZGluZ0NvaW5zIiwic2VhcmNoQ29pbnMiLCJxdWVyeSIsIkNPTU1PTl9DT0lOUyIsIkJUQyIsIkVUSCIsIkRPR0UiLCJTT0wiLCJYUlAiLCJBREEiLCJBVkFYIiwiRE9UIiwiTUFUSUMiLCJMSU5LIiwiZ2V0Q29tbW9uQ29pblByaWNlcyIsInN5bWJvbHMiLCJtYXAiLCJzIiwiZ2V0QlRDQW5kRE9HRURhdGEiLCJwcmljZXMiLCJidGNDaGFydCIsImRvZ2VDaGFydCIsImFsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/data/coingecko.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/feed/publisher.ts":
/*!*******************************!*\
  !*** ./lib/feed/publisher.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearFeed: function() { return /* binding */ clearFeed; },\n/* harmony export */   getFeedItems: function() { return /* binding */ getFeedItems; },\n/* harmony export */   publishToFeed: function() { return /* binding */ publishToFeed; },\n/* harmony export */   runPAWatchJob: function() { return /* binding */ runPAWatchJob; },\n/* harmony export */   runPolymarketFeedJob: function() { return /* binding */ runPolymarketFeedJob; },\n/* harmony export */   runTechAnalystFeedJob: function() { return /* binding */ runTechAnalystFeedJob; },\n/* harmony export */   startFeedScheduler: function() { return /* binding */ startFeedScheduler; },\n/* harmony export */   stopFeedScheduler: function() { return /* binding */ stopFeedScheduler; },\n/* harmony export */   subscribeToFeed: function() { return /* binding */ subscribeToFeed; },\n/* harmony export */   triggerAllJobs: function() { return /* binding */ triggerAllJobs; }\n/* harmony export */ });\n/* harmony import */ var _lib_agents_tech_analyst__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/agents/tech-analyst */ \"(app-pages-browser)/./lib/agents/tech-analyst.ts\");\n/* harmony import */ var _lib_agents_polymarket_analyst__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/agents/polymarket-analyst */ \"(app-pages-browser)/./lib/agents/polymarket-analyst.ts\");\n/* harmony import */ var _lib_agents_cfo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/agents/cfo */ \"(app-pages-browser)/./lib/agents/cfo.ts\");\n/* harmony import */ var _lib_trading_portfolio__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/trading/portfolio */ \"(app-pages-browser)/./lib/trading/portfolio.ts\");\n/**\n * Feed 发布系统\n * 管理所有 Agent 的情报发布到 Feed 流\n */ \n\n\n\n// 存储所有 Feed 项（实际项目中应使用数据库）\nlet feedStore = [];\nconst MAX_FEED_ITEMS = 100;\nconst subscribers = [];\n/**\n * 发布情报到 Feed\n */ function publishToFeed(item) {\n    feedStore.unshift(item);\n    // 限制存储数量\n    if (feedStore.length > MAX_FEED_ITEMS) {\n        feedStore = feedStore.slice(0, MAX_FEED_ITEMS);\n    }\n    // 通知订阅者\n    subscribers.forEach((callback)=>{\n        try {\n            callback(item);\n        } catch (error) {\n            console.error(\"[FeedPublisher] 订阅者错误:\", error);\n        }\n    });\n    console.log(\"[FeedPublisher] 已发布: \".concat(item.title));\n}\n/**\n * 订阅 Feed 更新\n */ function subscribeToFeed(callback) {\n    subscribers.push(callback);\n    // 返回取消订阅函数\n    return ()=>{\n        const index = subscribers.indexOf(callback);\n        if (index > -1) {\n            subscribers.splice(index, 1);\n        }\n    };\n}\n/**\n * 获取所有 Feed 项\n */ function getFeedItems(options) {\n    let items = [\n        ...feedStore\n    ];\n    if (options === null || options === void 0 ? void 0 : options.symbol) {\n        items = items.filter((item)=>item.symbol === options.symbol);\n    }\n    if (options === null || options === void 0 ? void 0 : options.type) {\n        items = items.filter((item)=>item.type === options.type);\n    }\n    if (options === null || options === void 0 ? void 0 : options.importance) {\n        items = items.filter((item)=>item.importance === options.importance);\n    }\n    if (options === null || options === void 0 ? void 0 : options.limit) {\n        items = items.slice(0, options.limit);\n    }\n    return items;\n}\n/**\n * 清空 Feed\n */ function clearFeed() {\n    feedStore = [];\n    console.log(\"[FeedPublisher] Feed 已清空\");\n}\n// ==================== Agent 定期发布任务 ====================\n/**\n * 技术分析员每5分钟发布任务\n */ async function runTechAnalystFeedJob() {\n    console.log(\"[FeedJob] 正在运行技术分析员 Feed 任务...\");\n    const techAnalyst = (0,_lib_agents_tech_analyst__WEBPACK_IMPORTED_MODULE_0__.getTechnicalAnalyst)();\n    const portfolio = (0,_lib_trading_portfolio__WEBPACK_IMPORTED_MODULE_3__.getPortfolioManager)();\n    try {\n        // 分析 BTC 和 DOGE\n        const result = await techAnalyst.processTask({\n            id: \"tech-feed-\".concat(Date.now()),\n            type: \"analyze_btc_doge\",\n            data: {},\n            priority: \"medium\",\n            createdAt: new Date()\n        });\n        if (result.success && result.data) {\n            const { analyses, prices } = result.data;\n            // 更新 Portfolio 中的价格\n            if (prices) {\n                prices.forEach((param)=>{\n                    let { symbol, price } = param;\n                    portfolio.updatePrice(symbol, price);\n                });\n                console.log(\"[FeedJob] 已更新 Portfolio 价格:\", prices.map((p)=>\"\".concat(p.symbol, \": $\").concat(p.price)).join(\", \"));\n            }\n            // 为每个分析结果创建 Feed 项\n            analyses.forEach((analysis)=>{\n                const topSignal = analysis.signals[0];\n                const importance = (topSignal === null || topSignal === void 0 ? void 0 : topSignal.confidence) > 0.7 ? \"high\" : (topSignal === null || topSignal === void 0 ? void 0 : topSignal.confidence) > 0.5 ? \"medium\" : \"low\";\n                const item = {\n                    id: \"tech-\".concat(analysis.symbol, \"-\").concat(Date.now()),\n                    type: \"technical_signal\",\n                    title: \"\".concat(analysis.symbol, \" 技术分析更新\"),\n                    content: \"RSI: \".concat(analysis.indicators.rsi, \" | MA7: $\").concat(analysis.indicators.ma7.toFixed(2), \" | 趋势: \").concat(analysis.indicators.trend, \"\\n\") + \"信号: \".concat((topSignal === null || topSignal === void 0 ? void 0 : topSignal.description) || \"暂无明确信号\"),\n                    symbol: analysis.symbol,\n                    timestamp: new Date(),\n                    importance,\n                    data: {\n                        source: \"tech-analyst\",\n                        rsi: analysis.indicators.rsi,\n                        ma7: analysis.indicators.ma7,\n                        ma14: analysis.indicators.ma14,\n                        trend: analysis.indicators.trend,\n                        signalType: topSignal === null || topSignal === void 0 ? void 0 : topSignal.type,\n                        signalConfidence: topSignal === null || topSignal === void 0 ? void 0 : topSignal.confidence\n                    }\n                };\n                publishToFeed(item);\n            });\n            console.log(\"[FeedJob] 技术分析员已发布 \".concat(analyses.length, \" 条情报\"));\n        }\n    } catch (error) {\n        console.error(\"[FeedJob] 技术分析员任务失败:\", error);\n    }\n}\n/**\n * Polymarket 专员每5分钟发布任务\n */ async function runPolymarketFeedJob() {\n    console.log(\"[FeedJob] 正在运行 Polymarket Feed 任务...\");\n    const polymarketAgent = (0,_lib_agents_polymarket_analyst__WEBPACK_IMPORTED_MODULE_1__.getPolymarketAgent)();\n    try {\n        const items = await polymarketAgent.generateIntelligence();\n        items.forEach((item)=>{\n            publishToFeed(item);\n        });\n        console.log(\"[FeedJob] Polymarket 已发布 \".concat(items.length, \" 条情报\"));\n    } catch (error) {\n        console.error(\"[FeedJob] Polymarket 任务失败:\", error);\n    }\n}\n/**\n * PA 每15分钟发布盯盘结果\n */ async function runPAWatchJob() {\n    console.log(\"[FeedJob] 正在运行 PA 盯盘任务...\");\n    const cfo = (0,_lib_agents_cfo__WEBPACK_IMPORTED_MODULE_2__.getCFOAgent)();\n    try {\n        // 分析 BTC 和 DOGE\n        const analyses = await cfo.analyzeMultiple([\n            \"BTC\",\n            \"DOGE\"\n        ]);\n        analyses.forEach((analysis)=>{\n            const item = {\n                id: \"pa-\".concat(analysis.symbol, \"-\").concat(Date.now()),\n                type: \"pa_analysis\",\n                title: \"\".concat(analysis.symbol, \" PA 研判报告\"),\n                content: cfo.formatAnalysisForChat(analysis),\n                symbol: analysis.symbol,\n                timestamp: new Date(),\n                importance: analysis.consensus.confidence > 0.7 ? \"high\" : \"medium\",\n                data: {\n                    source: \"pa\",\n                    bullConfidence: analysis.perspectives.bull.confidence,\n                    bearConfidence: analysis.perspectives.bear.confidence,\n                    consensusSentiment: analysis.consensus.sentiment,\n                    consensusAction: analysis.consensus.action,\n                    consensusConfidence: analysis.consensus.confidence\n                }\n            };\n            publishToFeed(item);\n        });\n        console.log(\"[FeedJob] PA 已发布 \".concat(analyses.length, \" 条情报\"));\n    } catch (error) {\n        console.error(\"[FeedJob] PA 任务失败:\", error);\n    }\n}\n// ==================== 调度器 ====================\nlet techInterval = null;\nlet polymarketInterval = null;\nlet cfoInterval = null;\n/**\n * 启动所有 Feed 定时任务\n */ function startFeedScheduler() {\n    console.log(\"[FeedScheduler] 正在启动...\");\n    // 立即执行一次\n    runTechAnalystFeedJob();\n    runPolymarketFeedJob();\n    runPAWatchJob();\n    // 技术分析员：每5分钟\n    techInterval = setInterval(runTechAnalystFeedJob, 5 * 60 * 1000);\n    // Polymarket：每5分钟\n    polymarketInterval = setInterval(runPolymarketFeedJob, 5 * 60 * 1000);\n    // PA：每15分钟\n    cfoInterval = setInterval(runPAWatchJob, 15 * 60 * 1000);\n    console.log(\"[FeedScheduler] 已启动 - 技术分析员: 5分钟, Polymarket: 5分钟, PA: 15分钟\");\n}\n/**\n * 停止所有 Feed 定时任务\n */ function stopFeedScheduler() {\n    if (techInterval) clearInterval(techInterval);\n    if (polymarketInterval) clearInterval(polymarketInterval);\n    if (cfoInterval) clearInterval(cfoInterval);\n    console.log(\"[FeedScheduler] 已停止\");\n}\n/**\n * 手动触发所有任务（用于测试）\n */ async function triggerAllJobs() {\n    await Promise.all([\n        runTechAnalystFeedJob(),\n        runPolymarketFeedJob(),\n        runPAWatchJob()\n    ]);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9mZWVkL3B1Ymxpc2hlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUcrRDtBQUNLO0FBQ3RCO0FBQ2U7QUFFOUQsMkJBQTJCO0FBQzNCLElBQUlJLFlBQWdDLEVBQUU7QUFDdEMsTUFBTUMsaUJBQWlCO0FBSXZCLE1BQU1DLGNBQWdDLEVBQUU7QUFFeEM7O0NBRUMsR0FDTSxTQUFTQyxjQUFjQyxJQUFzQjtJQUNsREosVUFBVUssT0FBTyxDQUFDRDtJQUVsQixTQUFTO0lBQ1QsSUFBSUosVUFBVU0sTUFBTSxHQUFHTCxnQkFBZ0I7UUFDckNELFlBQVlBLFVBQVVPLEtBQUssQ0FBQyxHQUFHTjtJQUNqQztJQUVBLFFBQVE7SUFDUkMsWUFBWU0sT0FBTyxDQUFDQyxDQUFBQTtRQUNsQixJQUFJO1lBQ0ZBLFNBQVNMO1FBQ1gsRUFBRSxPQUFPTSxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQywwQkFBMEJBO1FBQzFDO0lBQ0Y7SUFFQUMsUUFBUUMsR0FBRyxDQUFDLHdCQUFtQyxPQUFYUixLQUFLUyxLQUFLO0FBQ2hEO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxnQkFBZ0JMLFFBQXdCO0lBQ3REUCxZQUFZYSxJQUFJLENBQUNOO0lBRWpCLFdBQVc7SUFDWCxPQUFPO1FBQ0wsTUFBTU8sUUFBUWQsWUFBWWUsT0FBTyxDQUFDUjtRQUNsQyxJQUFJTyxRQUFRLENBQUMsR0FBRztZQUNkZCxZQUFZZ0IsTUFBTSxDQUFDRixPQUFPO1FBQzVCO0lBQ0Y7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU0csYUFDZEMsT0FLQztJQUVELElBQUlDLFFBQVE7V0FBSXJCO0tBQVU7SUFFMUIsSUFBSW9CLG9CQUFBQSw4QkFBQUEsUUFBU0UsTUFBTSxFQUFFO1FBQ25CRCxRQUFRQSxNQUFNRSxNQUFNLENBQUNuQixDQUFBQSxPQUFRQSxLQUFLa0IsTUFBTSxLQUFLRixRQUFRRSxNQUFNO0lBQzdEO0lB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QUFvQkssY0FBY0w7SUFDdEMsSUFBSUMsYUFBYUksY0FBY0o7SUFFL0J4RSxRQUFRQyxHQUFHLENBQUM7QUFDZDtBQUVBOztDQUVDLEdBQ00sZUFBZTRFO0lBQ3BCLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQztRQUNoQjlEO1FBQ0FtQztRQUNBRztLQUNEO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2ZlZWQvcHVibGlzaGVyLnRzPzIzZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBGZWVkIOWPkeW4g+ezu+e7n1xuICog566h55CG5omA5pyJIEFnZW50IOeahOaDheaKpeWPkeW4g+WIsCBGZWVkIOa1gVxuICovXG5cbmltcG9ydCB0eXBlIHsgSW50ZWxsaWdlbmNlSXRlbSB9IGZyb20gXCJAL2xpYi90eXBlc1wiO1xuaW1wb3J0IHsgZ2V0VGVjaG5pY2FsQW5hbHlzdCB9IGZyb20gXCJAL2xpYi9hZ2VudHMvdGVjaC1hbmFseXN0XCI7XG5pbXBvcnQgeyBnZXRQb2x5bWFya2V0QWdlbnQgfSBmcm9tIFwiQC9saWIvYWdlbnRzL3BvbHltYXJrZXQtYW5hbHlzdFwiO1xuaW1wb3J0IHsgZ2V0Q0ZPQWdlbnQgfSBmcm9tIFwiQC9saWIvYWdlbnRzL2Nmb1wiO1xuaW1wb3J0IHsgZ2V0UG9ydGZvbGlvTWFuYWdlciB9IGZyb20gXCJAL2xpYi90cmFkaW5nL3BvcnRmb2xpb1wiO1xuXG4vLyDlrZjlgqjmiYDmnIkgRmVlZCDpobnvvIjlrp7pmYXpobnnm67kuK3lupTkvb/nlKjmlbDmja7lupPvvIlcbmxldCBmZWVkU3RvcmU6IEludGVsbGlnZW5jZUl0ZW1bXSA9IFtdO1xuY29uc3QgTUFYX0ZFRURfSVRFTVMgPSAxMDA7XG5cbi8vIOiuoumYheiAheWbnuiwg1xudHlwZSBGZWVkU3Vic2NyaWJlciA9IChpdGVtOiBJbnRlbGxpZ2VuY2VJdGVtKSA9PiB2b2lkO1xuY29uc3Qgc3Vic2NyaWJlcnM6IEZlZWRTdWJzY3JpYmVyW10gPSBbXTtcblxuLyoqXG4gKiDlj5HluIPmg4XmiqXliLAgRmVlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHVibGlzaFRvRmVlZChpdGVtOiBJbnRlbGxpZ2VuY2VJdGVtKTogdm9pZCB7XG4gIGZlZWRTdG9yZS51bnNoaWZ0KGl0ZW0pO1xuICBcbiAgLy8g6ZmQ5Yi25a2Y5YKo5pWw6YePXG4gIGlmIChmZWVkU3RvcmUubGVuZ3RoID4gTUFYX0ZFRURfSVRFTVMpIHtcbiAgICBmZWVkU3RvcmUgPSBmZWVkU3RvcmUuc2xpY2UoMCwgTUFYX0ZFRURfSVRFTVMpO1xuICB9XG4gIFxuICAvLyDpgJrnn6XorqLpmIXogIVcbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChjYWxsYmFjayA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW0ZlZWRQdWJsaXNoZXJdIOiuoumYheiAhemUmeivrzpcIiwgZXJyb3IpO1xuICAgIH1cbiAgfSk7XG4gIFxuICBjb25zb2xlLmxvZyhgW0ZlZWRQdWJsaXNoZXJdIOW3suWPkeW4gzogJHtpdGVtLnRpdGxlfWApO1xufVxuXG4vKipcbiAqIOiuoumYhSBGZWVkIOabtOaWsFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlVG9GZWVkKGNhbGxiYWNrOiBGZWVkU3Vic2NyaWJlcik6ICgpID0+IHZvaWQge1xuICBzdWJzY3JpYmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgXG4gIC8vIOi/lOWbnuWPlua2iOiuoumYheWHveaVsFxuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gc3Vic2NyaWJlcnMuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHN1YnNjcmliZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIOiOt+WPluaJgOaciSBGZWVkIOmhuVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmVlZEl0ZW1zKFxuICBvcHRpb25zPzoge1xuICAgIGxpbWl0PzogbnVtYmVyO1xuICAgIHN5bWJvbD86IHN0cmluZztcbiAgICB0eXBlPzogc3RyaW5nO1xuICAgIGltcG9ydGFuY2U/OiBzdHJpbmc7XG4gIH1cbik6IEludGVsbGlnZW5jZUl0ZW1bXSB7XG4gIGxldCBpdGVtcyA9IFsuLi5mZWVkU3RvcmVdO1xuICBcbiAgaWYgKG9wdGlvbnM/LnN5bWJvbCkge1xuICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5zeW1ib2wgPT09IG9wdGlvbnMuc3ltYm9sKTtcbiAgfVxuICBcbiAgaWYgKG9wdGlvbnM/LnR5cGUpIHtcbiAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0udHlwZSA9PT0gb3B0aW9ucy50eXBlKTtcbiAgfVxuICBcbiAgaWYgKG9wdGlvbnM/LmltcG9ydGFuY2UpIHtcbiAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uaW1wb3J0YW5jZSA9PT0gb3B0aW9ucy5pbXBvcnRhbmNlKTtcbiAgfVxuICBcbiAgaWYgKG9wdGlvbnM/LmxpbWl0KSB7XG4gICAgaXRlbXMgPSBpdGVtcy5zbGljZSgwLCBvcHRpb25zLmxpbWl0KTtcbiAgfVxuICBcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIOa4heepuiBGZWVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckZlZWQoKTogdm9pZCB7XG4gIGZlZWRTdG9yZSA9IFtdO1xuICBjb25zb2xlLmxvZyhcIltGZWVkUHVibGlzaGVyXSBGZWVkIOW3sua4heepulwiKTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT0gQWdlbnQg5a6a5pyf5Y+R5biD5Lu75YqhID09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICog5oqA5pyv5YiG5p6Q5ZGY5q+PNeWIhumSn+WPkeW4g+S7u+WKoVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuVGVjaEFuYWx5c3RGZWVkSm9iKCk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zb2xlLmxvZyhcIltGZWVkSm9iXSDmraPlnKjov5DooYzmioDmnK/liIbmnpDlkZggRmVlZCDku7vliqEuLi5cIik7XG4gIFxuICBjb25zdCB0ZWNoQW5hbHlzdCA9IGdldFRlY2huaWNhbEFuYWx5c3QoKTtcbiAgY29uc3QgcG9ydGZvbGlvID0gZ2V0UG9ydGZvbGlvTWFuYWdlcigpO1xuICBcbiAgdHJ5IHtcbiAgICAvLyDliIbmnpAgQlRDIOWSjCBET0dFXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGVjaEFuYWx5c3QucHJvY2Vzc1Rhc2soe1xuICAgICAgaWQ6IGB0ZWNoLWZlZWQtJHtEYXRlLm5vdygpfWAsXG4gICAgICB0eXBlOiBcImFuYWx5emVfYnRjX2RvZ2VcIixcbiAgICAgIGRhdGE6IHt9LFxuICAgICAgcHJpb3JpdHk6IFwibWVkaXVtXCIsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5kYXRhKSB7XG4gICAgICBjb25zdCB7IGFuYWx5c2VzLCBwcmljZXMgfSA9IHJlc3VsdC5kYXRhIGFzIHsgXG4gICAgICAgIGFuYWx5c2VzOiBBcnJheTx7XG4gICAgICAgICAgc3ltYm9sOiBzdHJpbmc7XG4gICAgICAgICAgaW5kaWNhdG9yczoge1xuICAgICAgICAgICAgcnNpOiBudW1iZXI7XG4gICAgICAgICAgICBtYTc6IG51bWJlcjtcbiAgICAgICAgICAgIG1hMTQ6IG51bWJlcjtcbiAgICAgICAgICAgIHRyZW5kOiBzdHJpbmc7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBzaWduYWxzOiBBcnJheTx7XG4gICAgICAgICAgICB0eXBlOiBzdHJpbmc7XG4gICAgICAgICAgICBjb25maWRlbmNlOiBudW1iZXI7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgICAgICAgIH0+O1xuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZTtcbiAgICAgICAgfT47XG4gICAgICAgIHByaWNlczogQXJyYXk8eyBzeW1ib2w6IHN0cmluZzsgcHJpY2U6IG51bWJlciB9PjtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIOabtOaWsCBQb3J0Zm9saW8g5Lit55qE5Lu35qC8XG4gICAgICBpZiAocHJpY2VzKSB7XG4gICAgICAgIHByaWNlcy5mb3JFYWNoKCh7IHN5bWJvbCwgcHJpY2UgfSkgPT4ge1xuICAgICAgICAgIHBvcnRmb2xpby51cGRhdGVQcmljZShzeW1ib2wsIHByaWNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbRmVlZEpvYl0g5bey5pu05pawIFBvcnRmb2xpbyDku7fmoLw6YCwgcHJpY2VzLm1hcChwID0+IGAke3Auc3ltYm9sfTogJCR7cC5wcmljZX1gKS5qb2luKCcsICcpKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8g5Li65q+P5Liq5YiG5p6Q57uT5p6c5Yib5bu6IEZlZWQg6aG5XG4gICAgICBhbmFseXNlcy5mb3JFYWNoKGFuYWx5c2lzID0+IHtcbiAgICAgICAgY29uc3QgdG9wU2lnbmFsID0gYW5hbHlzaXMuc2lnbmFsc1swXTtcbiAgICAgICAgY29uc3QgaW1wb3J0YW5jZSA9IHRvcFNpZ25hbD8uY29uZmlkZW5jZSA+IDAuNyA/IFwiaGlnaFwiIDogXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvcFNpZ25hbD8uY29uZmlkZW5jZSA+IDAuNSA/IFwibWVkaXVtXCIgOiBcImxvd1wiO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaXRlbTogSW50ZWxsaWdlbmNlSXRlbSA9IHtcbiAgICAgICAgICBpZDogYHRlY2gtJHthbmFseXNpcy5zeW1ib2x9LSR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgIHR5cGU6IFwidGVjaG5pY2FsX3NpZ25hbFwiLFxuICAgICAgICAgIHRpdGxlOiBgJHthbmFseXNpcy5zeW1ib2x9IOaKgOacr+WIhuaekOabtOaWsGAsXG4gICAgICAgICAgY29udGVudDogYFJTSTogJHthbmFseXNpcy5pbmRpY2F0b3JzLnJzaX0gfCBNQTc6ICQke2FuYWx5c2lzLmluZGljYXRvcnMubWE3LnRvRml4ZWQoMil9IHwg6LaL5Yq/OiAke2FuYWx5c2lzLmluZGljYXRvcnMudHJlbmR9XFxuYCArXG4gICAgICAgICAgICAgICAgICAgYOS/oeWPtzogJHt0b3BTaWduYWw/LmRlc2NyaXB0aW9uIHx8IFwi5pqC5peg5piO56Gu5L+h5Y+3XCJ9YCxcbiAgICAgICAgICBzeW1ib2w6IGFuYWx5c2lzLnN5bWJvbCxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgaW1wb3J0YW5jZSxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBzb3VyY2U6IFwidGVjaC1hbmFseXN0XCIsXG4gICAgICAgICAgICByc2k6IGFuYWx5c2lzLmluZGljYXRvcnMucnNpLFxuICAgICAgICAgICAgbWE3OiBhbmFseXNpcy5pbmRpY2F0b3JzLm1hNyxcbiAgICAgICAgICAgIG1hMTQ6IGFuYWx5c2lzLmluZGljYXRvcnMubWExNCxcbiAgICAgICAgICAgIHRyZW5kOiBhbmFseXNpcy5pbmRpY2F0b3JzLnRyZW5kLFxuICAgICAgICAgICAgc2lnbmFsVHlwZTogdG9wU2lnbmFsPy50eXBlLFxuICAgICAgICAgICAgc2lnbmFsQ29uZmlkZW5jZTogdG9wU2lnbmFsPy5jb25maWRlbmNlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBwdWJsaXNoVG9GZWVkKGl0ZW0pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBbRmVlZEpvYl0g5oqA5pyv5YiG5p6Q5ZGY5bey5Y+R5biDICR7YW5hbHlzZXMubGVuZ3RofSDmnaHmg4XmiqVgKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltGZWVkSm9iXSDmioDmnK/liIbmnpDlkZjku7vliqHlpLHotKU6XCIsIGVycm9yKTtcbiAgfVxufVxuXG4vKipcbiAqIFBvbHltYXJrZXQg5LiT5ZGY5q+PNeWIhumSn+WPkeW4g+S7u+WKoVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuUG9seW1hcmtldEZlZWRKb2IoKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnNvbGUubG9nKFwiW0ZlZWRKb2JdIOato+WcqOi/kOihjCBQb2x5bWFya2V0IEZlZWQg5Lu75YqhLi4uXCIpO1xuICBcbiAgY29uc3QgcG9seW1hcmtldEFnZW50ID0gZ2V0UG9seW1hcmtldEFnZW50KCk7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgcG9seW1hcmtldEFnZW50LmdlbmVyYXRlSW50ZWxsaWdlbmNlKCk7XG4gICAgXG4gICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIHB1Ymxpc2hUb0ZlZWQoaXRlbSk7XG4gICAgfSk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYFtGZWVkSm9iXSBQb2x5bWFya2V0IOW3suWPkeW4gyAke2l0ZW1zLmxlbmd0aH0g5p2h5oOF5oqlYCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltGZWVkSm9iXSBQb2x5bWFya2V0IOS7u+WKoeWksei0pTpcIiwgZXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICogUEEg5q+PMTXliIbpkp/lj5HluIPnm6/nm5jnu5PmnpxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1blBBV2F0Y2hKb2IoKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnNvbGUubG9nKFwiW0ZlZWRKb2JdIOato+WcqOi/kOihjCBQQSDnm6/nm5jku7vliqEuLi5cIik7XG4gIFxuICBjb25zdCBjZm8gPSBnZXRDRk9BZ2VudCgpO1xuICBcbiAgdHJ5IHtcbiAgICAvLyDliIbmnpAgQlRDIOWSjCBET0dFXG4gICAgY29uc3QgYW5hbHlzZXMgPSBhd2FpdCBjZm8uYW5hbHl6ZU11bHRpcGxlKFtcIkJUQ1wiLCBcIkRPR0VcIl0pO1xuICAgIFxuICAgIGFuYWx5c2VzLmZvckVhY2goYW5hbHlzaXMgPT4ge1xuICAgICAgY29uc3QgaXRlbTogSW50ZWxsaWdlbmNlSXRlbSA9IHtcbiAgICAgICAgaWQ6IGBwYS0ke2FuYWx5c2lzLnN5bWJvbH0tJHtEYXRlLm5vdygpfWAsXG4gICAgICAgIHR5cGU6IFwicGFfYW5hbHlzaXNcIixcbiAgICAgICAgdGl0bGU6IGAke2FuYWx5c2lzLnN5bWJvbH0gUEEg56CU5Yik5oql5ZGKYCxcbiAgICAgICAgY29udGVudDogY2ZvLmZvcm1hdEFuYWx5c2lzRm9yQ2hhdChhbmFseXNpcyksXG4gICAgICAgIHN5bWJvbDogYW5hbHlzaXMuc3ltYm9sLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIGltcG9ydGFuY2U6IGFuYWx5c2lzLmNvbnNlbnN1cy5jb25maWRlbmNlID4gMC43ID8gXCJoaWdoXCIgOiBcIm1lZGl1bVwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc291cmNlOiBcInBhXCIsXG4gICAgICAgICAgYnVsbENvbmZpZGVuY2U6IGFuYWx5c2lzLnBlcnNwZWN0aXZlcy5idWxsLmNvbmZpZGVuY2UsXG4gICAgICAgICAgYmVhckNvbmZpZGVuY2U6IGFuYWx5c2lzLnBlcnNwZWN0aXZlcy5iZWFyLmNvbmZpZGVuY2UsXG4gICAgICAgICAgY29uc2Vuc3VzU2VudGltZW50OiBhbmFseXNpcy5jb25zZW5zdXMuc2VudGltZW50LFxuICAgICAgICAgIGNvbnNlbnN1c0FjdGlvbjogYW5hbHlzaXMuY29uc2Vuc3VzLmFjdGlvbixcbiAgICAgICAgICBjb25zZW5zdXNDb25maWRlbmNlOiBhbmFseXNpcy5jb25zZW5zdXMuY29uZmlkZW5jZSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHB1Ymxpc2hUb0ZlZWQoaXRlbSk7XG4gICAgfSk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYFtGZWVkSm9iXSBQQSDlt7Llj5HluIMgJHthbmFseXNlcy5sZW5ndGh9IOadoeaDheaKpWApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbRmVlZEpvYl0gUEEg5Lu75Yqh5aSx6LSlOlwiLCBlcnJvcik7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT0g6LCD5bqm5ZmoID09PT09PT09PT09PT09PT09PT09XG5cbmxldCB0ZWNoSW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG5sZXQgcG9seW1hcmtldEludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xubGV0IGNmb0ludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuXG4vKipcbiAqIOWQr+WKqOaJgOaciSBGZWVkIOWumuaXtuS7u+WKoVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRGZWVkU2NoZWR1bGVyKCk6IHZvaWQge1xuICBjb25zb2xlLmxvZyhcIltGZWVkU2NoZWR1bGVyXSDmraPlnKjlkK/liqguLi5cIik7XG4gIFxuICAvLyDnq4vljbPmiafooYzkuIDmrKFcbiAgcnVuVGVjaEFuYWx5c3RGZWVkSm9iKCk7XG4gIHJ1blBvbHltYXJrZXRGZWVkSm9iKCk7XG4gIHJ1blBBV2F0Y2hKb2IoKTtcbiAgXG4gIC8vIOaKgOacr+WIhuaekOWRmO+8muavjzXliIbpkp9cbiAgdGVjaEludGVydmFsID0gc2V0SW50ZXJ2YWwocnVuVGVjaEFuYWx5c3RGZWVkSm9iLCA1ICogNjAgKiAxMDAwKTtcbiAgXG4gIC8vIFBvbHltYXJrZXTvvJrmr4815YiG6ZKfXG4gIHBvbHltYXJrZXRJbnRlcnZhbCA9IHNldEludGVydmFsKHJ1blBvbHltYXJrZXRGZWVkSm9iLCA1ICogNjAgKiAxMDAwKTtcbiAgXG4gIC8vIFBB77ya5q+PMTXliIbpkp9cbiAgY2ZvSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChydW5QQVdhdGNoSm9iLCAxNSAqIDYwICogMTAwMCk7XG4gIFxuICBjb25zb2xlLmxvZyhcIltGZWVkU2NoZWR1bGVyXSDlt7LlkK/liqggLSDmioDmnK/liIbmnpDlkZg6IDXliIbpkp8sIFBvbHltYXJrZXQ6IDXliIbpkp8sIFBBOiAxNeWIhumSn1wiKTtcbn1cblxuLyoqXG4gKiDlgZzmraLmiYDmnIkgRmVlZCDlrprml7bku7vliqFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BGZWVkU2NoZWR1bGVyKCk6IHZvaWQge1xuICBpZiAodGVjaEludGVydmFsKSBjbGVhckludGVydmFsKHRlY2hJbnRlcnZhbCk7XG4gIGlmIChwb2x5bWFya2V0SW50ZXJ2YWwpIGNsZWFySW50ZXJ2YWwocG9seW1hcmtldEludGVydmFsKTtcbiAgaWYgKGNmb0ludGVydmFsKSBjbGVhckludGVydmFsKGNmb0ludGVydmFsKTtcbiAgXG4gIGNvbnNvbGUubG9nKFwiW0ZlZWRTY2hlZHVsZXJdIOW3suWBnOatolwiKTtcbn1cblxuLyoqXG4gKiDmiYvliqjop6blj5HmiYDmnInku7vliqHvvIjnlKjkuo7mtYvor5XvvIlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyaWdnZXJBbGxKb2JzKCk6IFByb21pc2U8dm9pZD4ge1xuICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgcnVuVGVjaEFuYWx5c3RGZWVkSm9iKCksXG4gICAgcnVuUG9seW1hcmtldEZlZWRKb2IoKSxcbiAgICBydW5QQVdhdGNoSm9iKCksXG4gIF0pO1xufVxuIl0sIm5hbWVzIjpbImdldFRlY2huaWNhbEFuYWx5c3QiLCJnZXRQb2x5bWFya2V0QWdlbnQiLCJnZXRDRk9BZ2VudCIsImdldFBvcnRmb2xpb01hbmFnZXIiLCJmZWVkU3RvcmUiLCJNQVhfRkVFRF9JVEVNUyIsInN1YnNjcmliZXJzIiwicHVibGlzaFRvRmVlZCIsIml0ZW0iLCJ1bnNoaWZ0IiwibGVuZ3RoIiwic2xpY2UiLCJmb3JFYWNoIiwiY2FsbGJhY2siLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciLCJ0aXRsZSIsInN1YnNjcmliZVRvRmVlZCIsInB1c2giLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJnZXRGZWVkSXRlbXMiLCJvcHRpb25zIiwiaXRlbXMiLCJzeW1ib2wiLCJmaWx0ZXIiLCJ0eXBlIiwiaW1wb3J0YW5jZSIsImxpbWl0IiwiY2xlYXJGZWVkIiwicnVuVGVjaEFuYWx5c3RGZWVkSm9iIiwidGVjaEFuYWx5c3QiLCJwb3J0Zm9saW8iLCJyZXN1bHQiLCJwcm9jZXNzVGFzayIsImlkIiwiRGF0ZSIsIm5vdyIsImRhdGEiLCJwcmlvcml0eSIsImNyZWF0ZWRBdCIsInN1Y2Nlc3MiLCJhbmFseXNlcyIsInByaWNlcyIsInByaWNlIiwidXBkYXRlUHJpY2UiLCJtYXAiLCJwIiwiam9pbiIsImFuYWx5c2lzIiwidG9wU2lnbmFsIiwic2lnbmFscyIsImNvbmZpZGVuY2UiLCJjb250ZW50IiwiaW5kaWNhdG9ycyIsInJzaSIsIm1hNyIsInRvRml4ZWQiLCJ0cmVuZCIsImRlc2NyaXB0aW9uIiwidGltZXN0YW1wIiwic291cmNlIiwibWExNCIsInNpZ25hbFR5cGUiLCJzaWduYWxDb25maWRlbmNlIiwicnVuUG9seW1hcmtldEZlZWRKb2IiLCJwb2x5bWFya2V0QWdlbnQiLCJnZW5lcmF0ZUludGVsbGlnZW5jZSIsInJ1blBBV2F0Y2hKb2IiLCJjZm8iLCJhbmFseXplTXVsdGlwbGUiLCJmb3JtYXRBbmFseXNpc0ZvckNoYXQiLCJjb25zZW5zdXMiLCJidWxsQ29uZmlkZW5jZSIsInBlcnNwZWN0aXZlcyIsImJ1bGwiLCJiZWFyQ29uZmlkZW5jZSIsImJlYXIiLCJjb25zZW5zdXNTZW50aW1lbnQiLCJzZW50aW1lbnQiLCJjb25zZW5zdXNBY3Rpb24iLCJhY3Rpb24iLCJjb25zZW5zdXNDb25maWRlbmNlIiwidGVjaEludGVydmFsIiwicG9seW1hcmtldEludGVydmFsIiwiY2ZvSW50ZXJ2YWwiLCJzdGFydEZlZWRTY2hlZHVsZXIiLCJzZXRJbnRlcnZhbCIsInN0b3BGZWVkU2NoZWR1bGVyIiwiY2xlYXJJbnRlcnZhbCIsInRyaWdnZXJBbGxKb2JzIiwiUHJvbWlzZSIsImFsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/feed/publisher.ts\n"));

/***/ })

});